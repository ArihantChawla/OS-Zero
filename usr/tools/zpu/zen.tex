\documentclass[llpt, twoside, a4paper]{book}
\usepackage[T1]{fontenc}
\usepackage{parskip}
%\usepackage{listings}
\usepackage{fancyvrb}
\usepackage{hyperref}
%\lstset{language=C, showspaces=false, breaklines=false}
\hypersetup{backref, colorlinks=true, linkcolor=blue}

\begin{document}

\title{\LARGE{Zen Processor Unit} \\*
       \large{Volume One, Programmer's Guide, revision 0.0.1}}
\author{Tuomo Petteri Venäläinen}
\date{\today}
\maketitle

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{4}
\setlength{\parindent}{0cm}

\tableofcontents

\part{Preface}

\chapter{Notes}

	\textbf{Brief}

	\textbf{Zen Processor Unit} aims to be a flexible, minimalistic, RISC-
	like load-store architecture. It's first going to be implemented as a
	virtual machine; hopefully later in hardware using FPGA. :)

	\textbf{Background and Future}

	One of the main goals of the project is to supply a fast-enough FPGA-
	implemented CPU for running old games using ScummVM. :)

\part{The Machine}

\chapter{Architecture}

	Zen Processor Unit is a load-store architecture, i.e. there's just one
	family of instructions (MOV*) to interface with memory; the rest of the
	instruction set operates on registers.

	Native word size is \textbf{32-bit}. Words are little endian, i.e.
	lowest byte first.

	\textbf{Extended data types} include rational numbers with signed 32-bit
	nominator and denominator as well as 32-bit and 64-bit IEEE754 floating
	point types (float and double, usually).

	\textbf{Rudimentary SIMD support} lets you do certain operations on
	several argument pairs in parallel; e.g., you could pack 4 8-bit bytes
	into 64-bit register as 16-bit integers and then add them, optionally
	with signed or unsigned saturation.

\chapter{Instruction Set}

	The ZEN instruction set was designed to resemble the C language closely,
	as well as support a RISC-oriented set of typical machine operations.

\section{Instruction Reference}

\subsection{Instruction Set}

	\textbf{Operands}

\begin{itemize}
	\item{\textbf{i} stands for immediate operand}
	\item{\textbf{r} stands for register operand}
	\item{\textbf{m} stands for memory operand}
\end{itemize}

	\textbf{Flags}

	Certain instructions set bits in the machine status word (MSW). This is
	documented here on per-instruction basis.

\begin{itemize}
	\item{\textbf{C} stands for carry flag (CF)}
	\item{\textbf{I} stands for interrupt flag (IF)}
	\item{\textbf{Z} stands for zero flag (ZF)}
	\item{\textbf{V} stands for overflow flag (VF)}
\end{itemize}

	\textbf{TODO}: stack/call conventions for certain instructions

\subsection{Instruction Table}

\subsubsection{Base Instruction Set}

\begin{tabular}{| l | l | l | l | l |}
	\hline
	Mnemonic     & Source      & Destination & Brief & Flags \\
	\hline
	\textbf{not} & r           & N/A         & op1 = ~op1; & Z \\
	\hline
	\textbf{and} & r/i & r & op2 = op2 \& op1; & Z \\
	\hline
        \textbf{or}  & r/i & r & op2 = op2 | op1; & N/A \\
	\hline
	\textbf{xor} & r/i & r & op2 = op2 \^ op1; & Z \\
	\hline
	\textbf{shr} & r/i & r & op2 = op2 >> op1; (zero-fill) & Z \\
	\hline
	\textbf{sar} & r/i & r & op2 = op2 >> op1; (sign-fill) & Z \\
	\hline
	\textbf{shl}  & r/i & r & op2 = op2 << op1; & O, C \\
	\hline
	\textbf{ror}  & r/i & r & op2 = op2 ROR op1; & C \\
	\hline
	\textbf{rol}  & r/i & r & op2 = op2 ROL op1; & C \\
	\hline
	\textbf{inc}  & r/i & N/A & op1++; & O \\
	\hline
	\textbf{dec}  & r/i & N/A & op1--; & O, Z \\
	\hline
	\textbf{add}  & r/i & r & op2 = op2 + op1; & O, Z \\
	\hline
	\textbf{sub}  & r/i & r & op2 = op2 - op1; & Z \\
	\hline
	\textbf{cmp}  & r/i & r & Compare two values and set flags & Z \\
	\hline
	\textbf{mul}  & r/i & r & op2 = op2 * op1; & O, Z \\
	\hline
	\textbf{div}  & r/i & r & op2 = op2 / op1; & Z \\
	\hline
	\textbf{mod}  & r/i & r & op2 = op2 \% op1; & N/A \\
	\hline
	\textbf{bz}   & r/i & N/A & branch to op1 if (CF == 0) & N/A \\
	\hline
	\textbf{bnz}  & r/i & N/A & branch to op1 if (CF != 0) & N/A \\
	\hline
	\textbf{blt}  & r/i & N/A & branch to op1 if (SF != 0) & N/A \\
	\hline
	\textbf{ble}  & r/i & N/A & branch to op1 if (SF != 0) || (ZF == 0) & N/A \\
	\hline
	\textbf{bgt}  & r/i & N/A & branch to op1 if (SF != 0) \&\& (ZF != 0) & N/A \\
	\hline
	\textbf{bge}  & r/i & N/A & branch to op1 if (SF != 0) || (ZF == 0) & N/A \\
	\hline
	\textbf{bo}   & r/i & N/A & branch to op1 if (OF != 0) & N/A \\
	\hline
	\textbf{bno}  & r/i & N/A & branch to op1 if (OF == 0) & N/A \\
	\hline
	\textbf{bc}   & r/i & N/A & branch to op1 if (CF != 0) & N/A \\
	\hline
	\textbf{bnc}  & r/i & N/A & branch to op1 if (CF == 0) & N/A \\
	\hline
	\textbf{pop}  & N/A & N/A & pop top of stack & N/A \\
	\hline
	\textbf{push} & r/i & N/A & push value on stack & N/A \\
	\hline
	\textbf{pusha} & r/i & N/A & push all registers on stack & N/A \\
	\hline
	\textbf{mov} & r/i/m & r/i/m & load or store 32-bit longword & N/A \\
	\hline
	\textbf{movb} & r/i/m & r/i/m & load or store 8-bit byte & N/A \\
	\hline
	\textbf{movw} & r/i/m & r/i/m & load or store 16-bit word & N/A \\
	\hline
	\textbf{movq} & r/i/m & r/i/m & load or store 64-bit word & N/A \\
	\hline
	\textbf{jmp} & r/i & N/A & unconditional branch & N/A \\
	\hline
	\textbf{call} & r/i & N/A & call subroutine; construct stack frame & N/A \\
	\hline
	\textbf{enter} & N/A & N/A & enter subroutine & N/A \\
	\hline
	\textbf{leave} & N/A & N/A & leave subroutine & N/A \\
	\hline
	\textbf{ret} & N/A & N/A & return from subroutine & N/A \\
	\hline
	\textbf{lmsw} & r/i & N/A & load machine status word & N/A \\
	\hline
	\textbf{smsw} & m & N/A & load machine status word & N/A \\
	\hline
\end{tabular}

\subsubsection{Rational Number Extensions}

\begin{tabular}{| l | l | l | l | l |}
	\hline
	Mnemonic     & Source      & Destination & Brief & Flags \\
	\hline
	\textbf{radd} & r/i & r/i & add two rational numbers & N/A \\
	\hline
	\textbf{rsub} & r/i & r/i & subtract two rational numbers & N/A \\
	\hline
	\textbf{rmul} & r/i & r/i & multiply two rational numbers & N/A \\
	\hline
	\textbf{rdiv} & r/i & r/i & divide two rational numbers & N/A \\
	\hline
\end{tabular}

\subsubsection{SIMD Extensions}

\begin{itemize}
	\item{for the SIMD instructions, argsz in opcode determines operand size}
	\item{saturation is chosen with ARITH\_SATS or ARITH\_SATU in opcode flags}
\end{itemize}

\begin{tabular}{| l | l | l | l | l |}
	\hline
	Mnemonic     & Source      & Destination & Brief & Flags \\
	\hline
	\textbf{vshrw} & r/i & r/i & shift 16-bit words right (zero-fill) & N/A \\
	\hline
	\textbf{vsarb} & r/i & r/i & shift 8-bit bytes right (sign-fill) & N/A \\
	\hline
	\textbf{vsarw} & r/i & r/i & shift 16-bit words right (sign-fill) & N/A \\
	\hline
	\textbf{vshlb} & r/i & r/i & shift 8-bit bytes left & N/A \\
	\hline
	\textbf{vshlw} & r/i & r/i & shift 16-bit words left & N/A \\
	\hline
	\textbf{vaddb} & r/i & r/i & add 8-bit bytes & N/A \\
	\hline
	\textbf{vaddbs} & r/i & r/i & add 8-bit bytes with signed saturation & N/A \\
	\hline
	\textbf{vaddbu} & r/i & r/i & add 8-bit bytes with unsigned saturation & N/A \\
	\hline
	\textbf{vaddw} & r/i & r/i & add 16-bit words & N/A \\
	\hline
	\textbf{vsubb} & r/i & r/i & subtract 8-bit bytes & N/A \\
	\hline
	\textbf{vsubbs} & r/i & r/i & subtract 8-bit bytes with signed saturation & N/A \\
	\hline
	\textbf{vsubbu} & r/i & r/i & subtract 8-bit bytes with unsigned saturation & N/A \\
	\hline
	\textbf{vsubw} & r/i & r/i & subtract 16-bit words & N/A \\
	\textbf{vmulb} & r/i & r/i & multiply 8-bit bytes & N/A \\
	\hline
	\textbf{vmulbs} & r/i & r/i & multiply 8-bit bytes with signed saturation & N/A \\
	\hline
	\textbf{vmulbu} & r/i & r/i & multiply 8-bit bytes with unsigned saturation & N/A \\
	\hline
	\textbf{vmulw} & r/i & r/i & multiply 16-bit words & N/A \\
	\hline
	\textbf{vdivb} & r/i & r/i & divide 8-bit bytes & N/A \\
	\hline
	\textbf{vdivw} & r/i & r/i & divide 16-bit words & N/A \\
	\hline
	\textbf{vunpkbs} & r/i & r/i & unpack 4 signed 8-bit bytes into 16-bit ones in a 64-bit word & N/A \\
	\hline
	\textbf{vunpkbu} & r/i & r/i & unpack 4 unsigned 8-bit bytes into 16-bit ones in a 64-bit word & N/A \\
	\hline
\end{tabular}

\chapter{Reference}

\section{Opcode Format}

	The following C structure is what the stock assembler uses for opcode
	output.

	\textbf{Opcode Structure}

\begin{verbatim}
struct zpuop {
    unsigned flg     : 4;       // instruction flags */
    unsigned inst    : 7;       // numerical instruction ID
    unsigned sflg    : 5;       // INDIR, INDEX, IMMED, ADR, REG
    unsigned src     : 4;       // 4-bit source register ID
    unsigned dflg    : 5;       // INDIR, INDEX, IMMED, ADR, REG
    unsigned dest    : 4;       // 4-bit destination register
    unsigned argsz   : 3;       // operation size is 1 << (opsize + 1) bytes
    int32\_t  args[EMPTY];      // optional arguments
};
\end{verbatim}

	\textbf{Notes}

\begin{itemize}
	\item{\textbf{flg} is per-instruction flags}
	\item{\textbf{inst} is the instruction ID}
	\item{\textbf{sflg and dflg} are source and destination addressing bits}
	\item{\textbf{src and dest} are source and destination register IDs}
	\item{\textbf{argsz} is the size of arguments; not necessarily register size}
	\item{\textbf{args} contains 0, 1, or 2 32- or 64-byte addresses or values}
\end{itemize}

\section{Instruction Set}

	\textbf{Operand Types}

\begin{itemize}
	\item{\textbf{r} stands for register operand}
	\item{\textbf{i} stands for immediate operand value}
	\item{\textbf{a} stands for immediate direct address operand}
	\item{\textbf{p} stands for indirect address operand}
	\item{\textbf{n} stands for indexed address operand}
	\item{\textbf{m} stands for all of \textbf{a, i, and n}}
\end{itemize}

	\textbf{Notes}

\begin{itemize}
	\item{C language doesn't specify whether right shifts are arithmetic or
	logical}
	\item{Arithmetic right shift fills leftmost 'new' bits with the sign
	bit, logical shift fills with zero; left shifts are always fill
	rightmost bits with zero}
\end{itemize}

	\textbf{Instructions}

	Below, I will list machine instructions and illustrate their relation
	to C.

	\textbf{Notes}

\begin{itemize}
	\item{the \textbf{inb()} and other functions dealing with I/O are
	usually declared through \textbf{<sys/io.h>}}
\end{itemize}

\subsection{Cheat Sheet}

\begin{tabular}{ | l | l | l | l | }
	\hline
	C Operation & Instruction & Operands       & Brief \\
	\hline
	~           & not         & r dest          & reverse all bits \\
	\&          & and         & r/i src, r dest & logical AND \\
	|           & or          & r/i src, r dest & logical OR \\
	\textasciicircum & xor    & r/i src, r dest & logical exclusive OR \\
	<<          & shl         & r/i cnt, r dest & shift left by count \\
	>>          & shr         & r/i cnt, r dest & arithmetic shift right \\
		    & shrl        & r/i cnt, r dest & logical shift right \\
	N/A         & ror         & r/i cnt, r dest & rotate right by count \\
	N/A         & rol         & r/i cnt, r dest & rotate left by count \\
	++          & inc         & r dest          & increment by one \\
	--          & dec         & r dest          & decrement by one \\
	+           & add         & r/i cnt, r dest & addition \\
	-           & sub         & r/i cnt, r dest & subtraction \\
	==, != etc. & cmp         & r/i src, r dest & comparison; sets MSW-flags \\
	**          & mul         & r/i src, r dest & multiplication \\
	/           & div         & r/i src, r dest & division \\
	\%          & mod         & r/i src, r dest & modulus \\
	==, !       & bz          & none            & branch if zero \\
	!=, (val)   & bnz         & none            & branch if not zero \\
	<           & blt         & none            & branch if less than \\
	<=          & ble         & none            & branch if less than or equal \\
	>           & bgt         & none            & branch if greater than \\
	>=          & bge         & none            & branch if greater than or equal \\
	N/A         & bo          & none            & branch if overflow \\
	N/A         & bno         & none            & branch if no overflow \\
	N/A         & bc          & none            & branch if carry \\
	N/A         & bnc         & none            & branch if no carry \\
	dest = *sp++ & pop         & r dest          & pop from stack \\
	*--sp = src & push        & r src           & push onto stack \\
	push(regs)  & pusha	  & N/A             & push all registers \\
	dest = src  & mov         & r/i/m src, r/m dest & load/store longword (32-bit) \\
	dest = src  & movb        & r/i/m src, r/m dest & load/store byte (8-bit) \\
	dest = src  & movw        & r/i/m src, r/m dest & load/store word (16-bit) \\
	dest = src  & movq        & r/i/m src, r/m dest & load/store word (64-bit) \\
	N/A         & jmp         & r/m dest        & continue execution at dest \\
	N/A         & call        & a/p dest        & call subroutine \\
	N/A         & enter       & none            & subroutine prologue \\
	N/A         & leave       & none            & subroutine epilogue \\
	N/A         & ret         & none            & return from subroutine \\
	N/A         & lmsw        & r/i dest        & load machine status word \\
	N/A         & smsw        & r/i src         & store machine status word \\
	\hline
\end{tabular}

\part{The Assembler}

\chapter{Zen Assembly}

\section{Syntax}

	\textbf{AT\&T Syntax}

	We use so-called AT\&T-syntax assembly. Perhaps the most notorious
	difference from Intel-syntax is the operand order; AT\&T lists the
	source operand first, destination second, whereas Intel syntax does it
	vice versa.

	\textbf{Symbol Names}

	Label names must start with an underscore or a letter; after that, the
	name may contain underscores, letters, and digits. Label names end with
	a ':', so like

\begin{verbatim}
	value:	.long 0xb4b5b6b7
\end{verbatim}

	would declare a longword value at the address of \textbf{value}.

	\textbf{Instructions}

	The instruction operand order is source first, then destination. For
	example,

\begin{verbatim}
	mov	8(%r0), val
\end{verbatim}

	would store the value from address \textbf{r0 + 8} to the address of
	the label \textbf{val}.

	\textbf{Operands}

	Register operand names are prefixed with a '\textbf{\%}. Immediate
	constants and direct addresses are prefixed with a \'textbf{\$}'. Label
	addresses are refered to as their names without prefixes.

	The assembler supports simple preprocessing (of constant-value
	expressions), so it is possible to do things such as

\begin{verbatim}
	.define	FLAG1	0x01
	.define	FLAG2	0x02

	mov	$(FLAG1| FLAG2), %r1
\end{verbatim}

	\textbf{Registers}

	Register names are prefixed with '\%'; there are 16 registers r0..r15.
	For example,

\begin{verbatim}
	add	%r0, %r1
\end{verbatim}

	would add the longword in r0 to r1.

	\textbf{Direct Addressing}

	Direct addressing takes the syntax

\begin{verbatim}
	mov	val, %r0
\end{verbatim}

	which moves the longword at \textbf{address val} into r0.

	\textbf{Indexed Addressing}

	Indexed	addressing takes the syntax

\begin{verbatim}
	mov	4(%r0), %r1
\end{verbatim}

	where 4 is an integral constant offset and r0 is a register name. In
	short, this would store the value at the address \textbf{r0 + 4} into
	r1.

	\textbf{Indirect Addressing}

	Indirect addresses are indicated with a \textbf{'*'}, so

\begin{verbatim}
	mov	*%r0, %r1
\end{verbatim}

	would store the value from the \textbf{address in the register r0}
	into register r1, whereas

\begin{verbatim}
	mov	*val, %r0
\end{verbatim}

	would move the value \textbf{pointed to by val} into r0.

	Note that the first example above was functionally equivalent with

\begin{verbatim}
	mov	(%r0), %r1
\end{verbatim}

	\textbf{Immediate Addressing}

	Immediate addressing takes the syntax

\begin{verbatim}
	mov	$str, %r0
\end{verbatim}

	which would store the \textbf{address of str} into r0.

\section{Assembler Directives}

section{Input Directives}

\subsection{.include}

	The \textbf{.include} directive takes the syntax

\begin{verbatim}
	.include <file.asm>
\end{verbatim}

	to insert file.asm into the translation stream verbatim.

\subsection{.import}

	The \textbf{.import} directive takes the syntax

\begin{verbatim}
	.import <file.asm>
\end{verbatim}

	or

\begin{verbatim}
	.import <file.obj>
\end{verbatim}

	to import foreign assembly or object files into the stream.
	\textbf{Note} that only symbols declared with \textbf{.globl} will be
	made globally visible to avoid namespace pollution.

section{Link Directives}

\subsection{.org}

	The \textbf{.org} directive takes a single argument and sets the linker
	location address to the given value.

\subsection{.space}

	The \textbf{.space} directive takes a single argument and advances the
	link location address by the given value.

\subsection{.align}

	The \textbf{.align} directive takes a single argument and aligns the
	next label, data, or instruction to a boundary of the given size.

\subsection{.globl}

	The \textbf{.globl} directive takes one or several symbol names
	arguments and declares the symbols to have global visibility (linkage).

section{Data Directives}

\subsection{.long}

	\textbf{.long} takes any number of arguments and declares in-memory
	32-bit entities.

\subsection{.byte}

	\textbf{.byte} takes any number of arguments and declares in-memory
	8-bit entities.

\subsection{.short}

	\textbf{.short} takes any number of arguments and declares in-memory
	16-bit entities.

\subsection{.asciz}

	\textbf{.asciz} takes a C-style string argument of characters enclosed
	within double quotes ('"'). Escape sequences '$\backslash$n' (newline),
	'$\backslash$t' (tabulator), and '$\backslash$r' (carriage return) are supported.

section{Preprocessor Directives}

\subsection{.define}

	\textbf{.define} lets one declare symbolic names for constant (numeric)
	values. For example, if you have

\end{document}

