Zero Processor Unit
-------------------

Preface
-------

The goal of the ZPU project is to implement a simple ALU and utilise software
floating point math. This would be done to facilitate building mini game
consoles using FPGA hardware such as Papilio with graphics and audio support.

ZPU shall use 64-bit registers with support for rational numbers as 32-bit
nominator and denominator fields as well as 64-bit IEEE double-precision
point values.

Zero will be a RISC-like system with a single load/store instruction that
operates on memory; the rest of the instruction set is used to manipulate
registers. In addition to these datatypes, the initial design supports 32-bit
integral values.

Registers
---------
- 12 64-bit general purpose registers
- frame pointer register
- stack pointer register
- program counter (instruction pointer) register
- machine status word register

Registers
---------

Mask Registers
--------------

Name	Brief			Notes
----	-----			-----
B0	all zero bits		64-bit
B0L	all zero bits		32-bit lower half of B0 for integer operations
B1	all one bits		64-bit
B1L	all one bits		32-bit lower half of B1 for integer operations

General Purpose Registers
-------------------------

Name	Brief			Notes
----	-----			-----
R0..R15	general purpose		for program use

Special Registers
-----------------

Name	Brief			Notes
----	-----			-----
FP	frame pointer		pointer to current stack frame
SP	stack pointer		pointer to current stack position
PC	program counter		pointer to next instruction to run
MSW	machine status word	status of the latest instruction executed

Machine Status Word
-------------------

The MSW register is used to store the following bits:

CF  - carry
IF  - interrupt flag (1 if interrupts pending)
VF  - overflow
ZF  - zero (result)

Base Instruction Set
--------------------

The instruction names in parentheses indicate potentially optional instructions
to keep the base design minimalistic.

Instruction	# of Arguments	Brief
/* logical bitwise instructions */
NOT		1		2's complement
AND		2		logical AND
OR		2		logical OR
XOR		2		logical exclusive OR

/* shift instructions */
SHR
(SAR)
SHL
(ROR)
(ROL)

/* ALU instructions */
(INC)		1		increment by one
(DEC)		1		decrement by one
ADD		2		addition
SUB		2		subtraction
CMP		2		comparison
MUL		2		multiplication
DIV		2		division
MOD	

/* comparative instructions */
BZ		1		branch if zero
BNZ		1		branch if non-zero
BLT		1		branch if less than
BLE		1		branch if less than or equal
BGT		1		branch if greater than
BGE		1		branch if greater than or equal to
BO		1		branch if overflow
BNO		1		branch if no overflow
BC		1		branch if carry
BNC		1		branch if no carry

/* stack operations */
POP		1		pop register from stack
PUSH		1		push register to stack
PUSHA		1		push all registers to stack

/* load/store operations */
MOV		1		move 32-bit word between register and memory
MOVB		1		move 8-bit byte between register and memory
MOVW		1		move 16-bit word between register and memory
MOVQ		1		move 64-bit word between register and memory
/* flow control */
JMP		1		jump to given memory addres
CALL		1		initiate subroutine call
(ENTER)		1		subroutine call prologue
(LEAVE)		1		subroutine call epilogue
RET		1		return from subroutine

/* machine status word */
LMSW
SMSW

Optional Instructions
---------------------

/* rational number operations */
RADD		2		rational addition
RSUB		2		rational subtraction
RMUL		2		rational multiplication
RDIV		2		rational division

/* SIMD "vector" operations */
VSHRB		2		shift 8-bit bytes right
VSHRW		2		shift 16-bit words right
VSARB		2		shift 8-bit bytes right arithmetically
VSARW		2		shift 16-bit words right arithmetically
VSHLB		2		shift 8-bit bytes left
VSHLW		2		shift 16-bit words left
VADDB		2		add 8-bit bytes
VADDW		2		add 16-bit words
VSUBB		2		add 8-bit bytes
VSUBW		2		add 16-bit words
VMULB		2		add 8-bit bytes
VMULW		2		add 16-bit words
VDIVB		2		add 8-bit bytes
VDIVW		2		add 16-bit words
