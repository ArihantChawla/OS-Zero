\documentclass[llpt, twoside, a4paper]{book}
\usepackage[T1]{fontenc}
\usepackage{parskip}
%\usepackage{listings}
\usepackage{fancyvrb}
\usepackage{hyperref}
%\lstset{language=C, showspaces=false, breaklines=false}
\hypersetup{backref, colorlinks=true, linkcolor=blue}

\begin{document}

\title{\LARGE{Zero Pseudo Machine} \\*
       \large{Volume One, Programmer's Guide, revision 0.0.1}}
\author{Tuomo Petteri Venäläinen}
\date{\today}
\maketitle

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{4}
\setlength{\parindent}{0cm}

\tableofcontents

\part{Preface}

\chapter{Notes}

	\textbf{Brief}

	Zero Pseudo Machine, ZPM, is a software-based virtual machine. The
	machine is programmed in its own assembly dialect; the instruction set
	is reminiscent of many current RISC-like implementations.
\part{Pseudo Machine}

\chapter{Architecture}

	\textbf{Notes}

	ZPM is an architecture with 32-bit machine words; room has been left in the
	implementation for 64-bit suppport.

	ZPM words are little-endian (LSB) in byte-order.

	There exists an instruction, \textbf{thr}, to start executing new
	threads from desired code locations in memory.
\newpage

\section{Memory Organization}

	\textbf{Notes}

	System page size is 4096 bytes.

\begin{tabular}{ | l | l | l | }
	\hline
	Address         & Purpose          & Brief \\
	\hline
	0               & interrupt vector & interrupt handler descriptors \\
	4096            & keyboard buffer  & keyboard input queue \\
	8192            & text segment     & application program code (read-execute) \\
	8192 + TEXTSIZE & data segment     & program data (read-write) \\
	DATA + DATASIZE & BSS segment      & uninitialised data (runtime-allocated and zeroed) \\
	MEMSIZE - 3.5 G & dynamic segment  & free space for slab allocator \\
	3.5 gigabytes   & graphics         & 32-bit ARGB-format draw buffer \\
	\hline
\end{tabular}

\begin{itemize}
	\item{the VM's 'physical' memory size is currently specified as
	\textbf{MEMSIZE}; this memory is mapped 1-to-1 to virtual address space}
	\item{thread stacks live at \textbf{MEMSIZE - thrid * THRSTKSIZE}, i.e.
	at top of 'physical'  address space}
\end{itemize}

\chapter{Instruction Set}

	The ZPM instruction set was designed to resemble the C language closely,
	as well as to support a RISC-oriented set of typical machine operations.

\section{Instruction Reference}

\subsection{Instruction Set}

	\textbf{Operands}

	The table below lists operand types.

\begin{itemize}
	\item{\textbf{i} stands for immediate operand}
	\item{\textbf{r} stands for register operand}
	\item{\textbf{m} stands for memory operand}
\end{itemize}

	\textbf{Flags}

	Certain instructions set bits in the machine status word register (MSW).
	This is	documented here on per-instruction basis.

\begin{itemize}
	\item{\textbf{z} stands for zero flag (ZF)}
	\item{\textbf{c} stands for carry flag (CF)}
	\item{\textbf{o} stands for overflow flag (OF)}
	\item{\textbf{s} stands for sign flag (SF)}
\end{itemize}

	\textbf{TODO}: stack/call conventions for certain instructions such as THR

\subsection{Instruction Table}

\begin{tabular}{| l | l | l | l | l |}
	\hline
	Mnemonic     & Operand \#1 & Operand \#2 & Brief & Flags \\
	\hline
	\textbf{not} & r & N/A & op1 = ~op1; & z \\
	\hline
	\textbf{and} & r, i & r & op2 = op2 \& op1; & z \\
	\hline
        \textbf{or}  & r, i & r & op2 = op2 | op1; & N/A \\
	\hline
	\textbf{xor} & r, i & r & op2 = op2 \^ op1; & z \\
	\hline
	\textbf{shl}  & r, i & r & op2 = op2 << op1; & o, c \\
	\hline
	\textbf{shr} & r, i & r & op2 = op2 >> op1; (zero-fill) & z \\
	\hline
	\textbf{sar} & r, i & r & op2 = op2 >> op1; (sign-fill) & z \\
	\hline
	\textbf{rol}  & r, i & r & op2 = op2 ROL op1; & c \\
	\hline
	\textbf{ror}  & r, i & r & op2 = op2 ROR op1; & c \\
	\hline
	\textbf{inc}  & r, i & N/A & op1++; & o \\
	\hline
	\textbf{dec}  & r, i & N/A & op1--; & o, z \\
	\hline
	\textbf{add}  & r, i & r & op2 = op2 + op1; & o, z \\
	\hline
	\textbf{sub}  & r, i & r & op2 = op2 - op1; & s, z \\
	\hline
	\textbf{cmp}  & r, i & r & compare two values and set flags & s, z \\
	\hline
	\textbf{mul}  & r, i & r & op2 = op2 * op1; & o, s, z \\
	\hline
	\textbf{div}  & r, i & r & op2 = op2 / op1; & s, z \\
	\hline
	\textbf{jmp}  & r, i & branch to op1 & N/A \\
	\hline
	\textbf{bz}   & r, i & N/A & branch to op1 if (CF == 0) & N/A \\
	\hline
	\textbf{bnz}  & r, i & N/A & branch to op1 if (CF != 0) & N/A \\
	\hline
	\textbf{blt}  & r, i & N/A & branch to op1 if (SF != 0) & N/A \\
	\hline
	\textbf{ble}  & r, i & N/A & branch to op1 if (SF != 0) || (ZF == 0) & N/A \\
	\hline
	\textbf{bgt}  & r, i & N/A & branch to op1 if (SF != 0) \&\& (ZF != 0) & N/A \\
	\hline
	\textbf{bge}  & r, i & N/A & branch to op1 if (SF != 0) || (ZF == 0) & N/A \\
	\hline
	\textbf{bo}   & r, i & N/A & branch to op1 if (OF != 0) & N/A \\
	\hline
	\textbf{bno}  & r, i & N/A & branch to op1 if (OF == 0) & N/A \\
	\hline
	\textbf{bc}   & r, i & N/A & branch to op1 if (CF != 0) & N/A \\
	\hline
	\textbf{bnc}  & r, i & N/A & branch to op1 if (CF == 0) & N/A \\
	\hline
	\textbf{pop}  & r & N/A & pop top of stack & N/A \\
	\hline
	\textbf{popa} & N/A & N/A & pop all registers from stack & N/A \\
	\hline
	\textbf{push} & r, i & N/A & push value on stack & N/A \\
	\hline
	\textbf{pusha} & N/A & N/A & push all register on stack & N/A \\
	\hline
	\textbf{lda} & r, i, m & r & load 32-bit longword & N/A \\
	\hline
	\textbf{sta} & r & r, i, m & store 32-bit longword & N/A \\
	\hline
	\textbf{call} & r, i & N/A & call subroutine; construct stack frame & N/A \\
	\hline
	\textbf{enter} & N/A & N/A & enter subroutine & N/A \\
	\hline
	\textbf{leave} & N/A & N/A & leave subroutine & N/A \\
	\hline
	\textbf{ret} & N/A & N/A & return from subroutine & N/A \\
	\hline
	\textbf{thr} & m & N/A & start new thread at address & N/A \\
	\hline
	\textbf{ltb} & r, i & N/A & load thread-local storage base address & N/A \\
	\hline
	\textbf{ldr} & r, m & r & load special register & N/A \\
	\hline
	\textbf{str} & r & r, m & store special register & N/A \\
	\hline
	\textbf{rst} & m & N/A & reset machine & N/A \\
	\hline
	\textbf{hlt} & m & N/A & halt machine & N/A \\
	\hline
	\textbf{inb} & r, i & N/A & read 8-bit byte from input port & N/A \\
	\hline
	\textbf{inw} & r, i & N/A & read 16-bit word from input port & N/A \\
	\hline
	\textbf{inl} & r, i & N/A & read 32-bit longword from input port & N/A \\
	\hline
	\textbf{outb} & r, i & N/A & write 8-bit byte to input port & N/A \\
	\hline
	\textbf{outw} & r, i & N/A & write 16-bit word to input port & N/A \\
	\hline
	\textbf{outl} & r, i & N/A & write 32-bit longword to input port & N/A \\
	\hline
\end{tabular}

\subsection{I/O Port Map}

	\textbf{I/O Address Space}

	The I/O address space maps 65,536 I/O ports to unsigned 16-bit address
	space.
	
\begin{tabular}{| l | l | l | l | l |}
	\hline
	Port \# & Name & Brief \\
	\textbf{0x0000} & STDIN & keyboard input \\
	\hline
	\textbf{0x0001} & STDOUT & console output \\
	\hline
	\textbf{0x0002} & STDERR & error output \\
	\hline
\end{tabular}

\chapter{Assembly}

\section{Syntax}

	\textbf{AT\&T Syntax}

	We use so-called AT\&T-syntax assembly. Perhaps the most notorious
	difference from Intel-syntax is the operand order; AT\&T lists the
	source operand first, destination second, whereas Intel syntax does it
	vice versa.

	\textbf{Symbol Names}

	Label names must start with an underscore or a letter; after that, the
	name may contain underscores, letters, and digits. Label names end with
	a ':', so like

\begin{verbatim}
	value:	.long 0xb4b5b6b7
\end{verbatim}

	would declare a longword value at the address of \textbf{value}.

	\textbf{Instructions}

	The instruction operand order is source first, then destination. For
	example,

\begin{verbatim}
	mov	8(%r0), val
\end{verbatim}

	would store the value from address \textbf{r0 + 8} to the address of
	the label \textbf{val}.

	\textbf{Operands}

	Register operand names are prefixed with a '\textbf{\%}. Immediate
	constants and direct addresses are prefixed with a \'textbf{\$}'. Label
	addresses are refered to as their names without prefixes.

	The assembler supports simple preprocessing (of constant-value
	expressions), so it is possible to do things such as

\begin{verbatim}
	.define	FLAG1	0x01
	.define	FLAG2	0x02

	mov	$(FLAG1| FLAG2), %r1
\end{verbatim}

	\textbf{Registers}

	Register names are prefixed with '\%'; there are 16 registers r0..r15.
	For example,

\begin{verbatim}
	add	%r0, %r1
\end{verbatim}

	would add the longword in r0 to r1.

	\textbf{Direct Addressing}

	Direct addressing takes the syntax

\begin{verbatim}
	mov	val, %r0
\end{verbatim}

	which moves the longword at \textbf{address val} into r0.

	\textbf{Indexed Addressing}

	Indexed	addressing takes the syntax

\begin{verbatim}
	mov	4(%r0), %r1
\end{verbatim}

	where 4 is an integral constant offset and r0 is a register name. In
	short, this would store the value at the address \textbf{r0 + 4} into
	r1.

	\textbf{Indirect Addressing}

	Indirect addresses are indicated with a \textbf{'*'}, so

\begin{verbatim}
	mov	*%r0, %r1
\end{verbatim}

	would store the value from the \textbf{address in the register r0}
	into register r1, whereas

\begin{verbatim}
	mov	*val, %r0
\end{verbatim}

	would move the value \textbf{pointed to by val} into r0.

	Note that the first example above was functionally equivalent with

\begin{verbatim}
	mov	(%r0), %r1
\end{verbatim}

	\textbf{Immediate Addressing}

	Immediate addressing takes the syntax

\begin{verbatim}
	mov	$str, %r0
\end{verbatim}

	which would store the \textbf{address of str} into r0.

\section{Assembler Directives}

\section{Input Directives}

\subsection{.include}

	The \textbf{.include} directive takes the syntax

\begin{verbatim}
	.include <file.asm>
\end{verbatim}

	to insert file.asm into the translation stream verbatim.

\subsection{.import}

	The \textbf{.import} directive takes the syntax

\begin{verbatim}
	.import <file.asm>
\end{verbatim}

	or

\begin{verbatim}
	.import <file.obj>
\end{verbatim}

	to import foreign assembly or object files into the stream.
	\textbf{Note} that only symbols declared with \textbf{.globl} will be
	made globally visible to avoid namespace pollution.

\section{Link Directives}

\subsection{.org}

	The \textbf{.org} directive takes a single argument and sets the linker
	location address to the given value.

\subsection{.space}

	The \textbf{.space} directive takes a single argument and advances the
	link location address by the given value.

\subsection{.align}

	The \textbf{.align} directive takes a single argument and aligns the
	next label, data, or instruction to a boundary of the given size.

\subsection{.globl}

	The \textbf{.globl} directive takes one or several symbol names
	arguments and declares the symbols to have global visibility (linkage).

\section{Data Directives}

\subsection{.long}

	\textbf{.long} takes any number of arguments and declares in-memory
	32-bit entities.

\subsection{.byte}

	\textbf{.byte} takes any number of arguments and declares in-memory
	8-bit entities.

\subsection{.short}

	\textbf{.short} takes any number of arguments and declares in-memory
	16-bit entities.

\subsection{.asciz}

	\textbf{.asciz} takes a C-style string argument of characters enclosed
	within double quotes ('"'). Escape sequences '$\backslash$n' (newline),
	'$\backslash$t' (tabulator), and '$\backslash$r' (carriage return) are supported.

\subsection{Preprocessor Directives}

\section{.define}

	\textbf{.define} lets one declare symbolic names for constant (numeric)
	values. For example, if you have

	\textbf{<hook.def>}

\begin{verbatim}
        .define STDIN  0
        .define STDOUT 1
        .define STDERR 2
\end{verbatim}

\section{Input and Output}

	The pseudo machine uses some predefined ports for keyboard and console
	I/O. The currently predefined ports are

\begin{tabular}{ | l | l | l | }
	\hline
	Port & Use            & Notes \\
	\hline
	0x00 & keyboard input & interrupt-driven \\
	0x01 & console output & byte stream \\
	0x02 & error output   & directed to console by default \\
	\hline
\end{tabular}

\section{Simple Program}

	The following code snippet prints the string \"hello\" + a newline to
	the console. Note that the string is saved using the standard C
	convention of NUL-character termination.

\begin{verbatim}
        msg:        .asciz	"hello\n"

        .align      4
        
        _start:        
                sta        $msg, %r0
                ldb        *%r0, %r1
                ldb        $0x01, %r2
                cmp        $0x00, %r1
                bz         done
        loop:
                inc        %r0
                outb       %r1, %r2
                ldb       *%r0, %r1
                cmp        $0x00, %r1
                bnz        loop
        done:
                hlt
\end{verbatim}

\section{Threads}

	The pseudo machine supports hardware threads with the \textbf{thr}
	instruction. It takes a single argument, which specifies the new
	execution start address; function arguments should be passed in
	registers.

\section{Example Program}

	The following piece of code shows simple utilisation of threads.

\begin{verbatim}
        .import <bzero.asm>

        memzero:
                mov        $65536, %r0       // address
                mov        $4096, %r1        // length
                call       bzero
                hlt

        _start:
                thr        $memzero
                hlt
\end{verbatim}


\section{Interrupts}
	Software- and CPU-generated interrupts are often refered to as
	\textbf{traps}. I call those and hardware-generated
	\textbf{interrupt requests} interrupts, collectively.

\subsection{Interrupt Interface}

	The lowest page (4096 bytes) in virtual machine address space contains
	the \textbf{interrupt vector}, i.e. a table of interrupt handler
	addresses to trigger them.

	Interrupt handler invokations only push the \textbf{program counter}
	and \textbf{old frame pointer}, so you need to reserve the registers
	you use manually. This is so interrupts could be as little overhead as
	possible to handle.

\subsection{Keyboard Input}

	In order to read keyboard input without polling, we need to hook the
	\textbf{interrupt 0}. This is done in two code modules; an interrup
	handler as well as other support code.

	I will illustrate the interrupt handler first.

\subsection{Keyboard Interrupt Handler}

	\textbf{TODO: example interrupt handler}

\subsubsection{Keyboard Support Code}

	\textbf{TODO: queue keypresses in 16-bit values; 32-bit if full Unicode requested}.

\end{document}

