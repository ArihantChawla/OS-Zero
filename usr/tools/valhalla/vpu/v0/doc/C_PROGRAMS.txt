C Programs and Their Translation to Assembly
--------------------------------------------

Preface
-------

The instruction sets of modern microprocessors tend to have a lot in common with
the C programming language; typically, C operators have their analogues as a
subset of the instruction sets.

The interesting thing to know about C's close relation to the machine lays in
translating C to assembly; as assembly is "symbolic machine code," it's
practically equivalent to translating C to machine code, just at a bit higher
level.

Before we get into the translation, let's take a closer look at the anatomy of
a typical program compiled and assembled from C code.

PROGRAM ANATOMY
---------------

Code Segments
-------------

I will present a typical, slightly simplified organization of program code and
data segments. I'm not including the varying debugging- and such segments that
may be present in existing programs.

The Text Segment
----------------

The text segment contains the executable code. It's typically write-protected,
and on many architectures execute-only, i.e. you cannot even read the segment
directly from your code. This not only protects the program from your mistakes
of accidentally overwriting code, but also makes the life of malicious
programmers trying to exploit your code more miserable. Hardware providing
support, the text-segment should be the only one from which you are allowed to
execute code.

The ROData Segment
------------------

The read-only data segments contains immutable data, with a notable example
being string literals. TODO: what else goes in here?

The Data Segment
----------------

The data segment can be read and written. It consists of initialised global data
as well as static data internal to functions; the latter cannot be stored in
stack-space as the values would not retain their value due to the dynamic nature
of the stack.

The "BSS" Segment
-----------------

The name BSS has its origins in the term "Block Started by Symbol"; this may
also be called the heap segment. The segment is allocated at runtime and
contains uninitialised global data (zeroed at run/allocation-time). In earlier
Unix-like C libraries, the dynamic "malloc-style" memory allocator might use
this segment, but these days, it typically operates with safer and more flexible
(for the operating system kernel) memory-mapping interface provided by mmap()
and related functions.

The Stack Segment
-----------------

The stack segment is traditionally located high (often at top) in your address
space. The usual arrangement is for this segment to grow down address-wise. This
is where function-internal automatic variables, function-call stack-frames, and
related data live in.

PROGRAM RUN MODEL
-----------------

Machine Registers
-----------------
- program counter
- frame & stack pointers
- return address

Stack Frames
------------
- caller-save registers
- stack-arguments for function calls (some arguments are usually in registers)
- return address
- caller frame pointer
- callee-save registers
- automatic variables

PROGRAM TRANSLATION
-------------------
- crt0
- variables/stack/registers
- flow control; conditionals, loops, branches, switch/jump tables,
  function calls

FLOW CONTROL
------------

Loops
-----

These example loops do a simple operation of copying 64 memory values from the
region pointed to by src to the one pointed to by dest.

for Loop
--------

C Syntax
--------

lim = 64;
for ( ndx = 0 ; ndx < lim ; ndx++) {
    dest[ndx] = src[ndx];
}

Assembly Syntax
---------------

    xor    %r0, %r0             ; ndx = 0;
    ldr    $64, %r1             ; lim = 64;
_loop:
    cmp    %r0, %r1             ; ndx - lim
    jeq    _done                ; ndx == lim
    ldr    %r0(%r2), %r4        ; tmp = src[ndx];
    str    %r4, %r0(%r3)        ; dest[ndx] = tmp;
    inc    %r0                  ; ndx++;
    jmp    _loop                ; loop again
_done:
    ; REST OF FUNCTION

while Loop
----------

C Syntax
--------

lim = 64;
ndx = 0;
while (lim--) {
    dest[lim] = src[lim];
}

Assembly Syntax
---------------

    xor    %r0, %r0             ; ndx = 0;
    ldr    $64, %r1             ; lim = 64;
_loop:
    cmp    $0, %r1              ; lim - 0
    dec    %r1                  ; ndx--;
    jeq    _done                ; ndx == lim
    ldr    %r1(%r2), %r4        ; tmp = src[lim];
    str    %r4, %r1(%r3)        ; dest[lim] = tmp;
    jmp    _loop                ; loop again
_done:
    ; REST OF FUNCTION

do-while Loop
-------------

C Syntax
--------

ndx = 63;
do {
   dest[ndx] = src[ndx];
} while (ndx--);

Assembly Syntax
---------------

    xor    %r0, %r0             ; ndx = 0;
_loop:
    ; LOOP BODY
    ldr    %r0(%r2), %r4        ; tmp = src[ndx];
    str    %r4, %r0(%r3)        ; dest[ndx] = tmp;
    dec    %r1                  ; ndx--;
    cmp    $0, %r1              ; lim - 0
    jne    _loop                ; loop if lim != 0
    ; REST OF FUNCTION

Switch Statement
----------------

This switch statement demonstrates a Duff's device to set 64 contiguous memory
locations starting from the one pointed to by dest to 0 (zero). In effect, this
is similar to unrolling a loop by 8 steps.

val = 64;
while (val) {
    switch (val) {
        default:
        case 8:
            dest[7] = zero;
        case 7:
            dest[6] = zero;
        case 6:
            dest[5] = zero;
        case 5:
            dest[4] = zero;
        case 4:
            dest[3] = zero;
        case 3:
            dest[2] = zero;
        case 2:
            dest[1] = zero;
        case 1:
            dest[0] = zero;
        case 0:

            break;
    }
    val -= 4;
}

