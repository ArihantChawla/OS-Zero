%\documentclass[llpt, twoside, a4paper]{book}
\documentclass[llpt, a4paper]{book}
\usepackage[T1]{fontenc}
\usepackage{parskip}
\usepackage{minted}
\usepackage{fancyvrb}
\usepackage{hyperref}
%\lstset{language=assembly, showspaces=false, breaklines=false}
\hypersetup{backref, colorlinks=true, linkcolor=blue}

\begin{document}

\title{\LARGE{Valhalla Processor Unit 0 - V0} \\*
       \large{Volume One, Programmer's Guide, revision 0.0.1}}
\author{Tuomo Petteri Venäläinen}
\date{\today}
\maketitle

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{4}
\setlength{\parindent}{0cm}

\tableofcontents

\part{Preface}

\chapter{Notes}

	\textbf{Brief}

	Valhalla Processor Unit 0, V0, is a software-based virtual machine. The
	machine is programmed in its own assembly dialect; the instruction set
	is reminiscent of many current RISC-like implementations.

	I'm planning to experiment with FPGA-based processor design in the
	future.

\part{Architecture}

\chapter{Overview}

	\textbf{Notes}

	V0 is an architecture with 32-bit machine words; room has been left in
	the implementation for future 64-bit suppport.

	V0 words are little-endian (LSB) in byte-order.

\section{Register File}

        \textbf{Brief}
        To keep life simple, V0 starts small. The register types in use are
        scalar, temporary, and floating-point ones.

\subsection{General-Purpose Registers}

\begin{tabular}{ | l | l | l | l | }
        \hline
        Registers & Width  & Purpose           & Example \\
        \hline
        R0..R15   & 32-bit & Scalar Registers         & Integer Addition \\
        \hline
        T0..T15   & 64-bit & Temporary Registers      & Multiplication \\
        \hline
        F0..F15   & 64-bit & Floating-Point Registers & Floating-Point Operations \\
        \hline
\end{tabular}

        \subsection{Special Registers}

\begin{tabular}{ | l | l | l | l | }
        \hline
        Name & Brief               & Purpose                       & Writable \\
        \hline
        PC   & Program Counter     & Instruction Offset/Pointer    & No \\
        \hline
        FP   & Frame Pointer       & Stack Frame for Functions     & Yes \\
        \hline
        SP   & Stack Pointer       & Local [Variable] Stack        & Yes \\
        \hline
        MSW  & Machine Status Word & Processor Status and Features & Low 16 Bits (POP) \\
        \hline
\end{tabular}

\section{Memory Subsystem}

        \textbf{Brief}

        As a 32-bit system, it's natural to support full 4-gigabyte 32-bit
        address space with some provisions; I/O ports are implemented as a
        separate address space, memory-mapped I/O has reserved regions, and
        so does the operating system space.

\section{Input-Output}

        \textbf{Brief}
        Inspired by former Intel, AMD, and competitor PC-processors, we have a
        reasonable-size I/O-port address space of 65536 ports.

        I will reserve ports for things such as keyboard input, text-mode
        screen output, as well as timers and other standard peripherals.

\chapter{Computation Units}

\section{Address Unit}

        \textbf{Brief}

        Address calculations done by the processor.

\section{Scalar Unit}

        \textbf{Brief}

        It may help you to think of the scalar units as a simple calculator of
        sorts.

\subsection{Scalar Adder}
\textbf{0x0 - carry/borrow}

\begin{tabular}{ | l | l | l | l | }
        \hline
        Mnemonic & Opcode & Brief                   & Notes \\
        \hline
        NOP      & 0x00      & No Operation            & Dummy or Delay Operation \\
        \hline
        INC      & 0x01      & Increment By One        & \\
        \hline
        DEC      & 0x02      & Decrement By One        & \\
        \hline
        ADD      & 0x04      & Addition                & SIGN-bit, SATU-bit \\
        \hline
        ADC      & 0x05      & Addition with Carry     & 0x01 mean use carry \\
        \hline
        SUB      & 0x06      & Subtraction             & SIGN-bit, SATU-bit \\
        \hline
        SBB      & 0x07      & Subtraction with Borrow & 0x01 -> borrow \\
        \hline
\end{tabular}

\subsection{Scalar Shifter}
\textbf{0x01 - arithmetical shift}

\begin{tabular}{ | l | l | l | }
        Mnemonic & Opcode & Brief \\
        \hline
        SHR      & 0x08 & Shift Right Logical \\
        \hline
        SAR      & 0x09 & Shift Right Arithmetical \\
        \hline
        SLL      & 0x0a & Shift Left Logical \\
        \hline
        SAL      & 0x0b & Shift Left Arithmetical \\
        \hline
\end{tabular}

\subsection{Scalar Logic}

\begin{tabular}{ | l | l | l | }
        Mnemonic & Opcode & Brief \\
        \hline
        NOT      & 0x0c & Negation \\
        \hline
        AND      & 0x0d & Conjunction \\
        \hline
        XOR      & 0x0e & Exclusive Disjunction \\
        \hline
        OR       & 0x0f & Disjunction \\
        \hline
\end{tabular}

\subsection{Scalar Reciprocal}

        \textbf{Brief}

        Unsigned and signed reciprocal are used for unsigned and signed division
        by ``reverse multiplication'', respectively.

        \textbf{0x01 - signed operation}

\begin{tabular}{ | l | l | l | }
        Mnemonic & Opcode & Brief \\
        \hline
        CRU      & 0x10 & Unsigned Reciprocal \\
        \hline
        CRS      & 0x11 & Signed Reciprocal \\
        \hline
\end{tabular}

\subsection{Scalar Multiplication}

        \textbf{Brief}

        Unsigned and signed multiplication or ``division'' by multiplying with
        a precalculated reciprocal value.

        \textbf{0x01 - signed operation}

\begin{tabular}{ | l | l | l | }
        Mnemonic & Opcode & Brief \\
        \hline
        MLU      & 0x12 & Unsigned Multiplication \\
        \hline
        MLS      & 0x13 & Signed Multiplication \\
        \hline
\end{tabular}

\section{Memory Operations}

\subsection{Load-Store}

        \textbf{Brief}

        LDR an STR instructions are used to load registers from and store
        registers into memory, respectively.

\begin{tabular}{ | l | l | l | }
        Mnemonic & Opcode & Brief \\
        \hline
        LDR      & 0x14 & Load Register \\
        \hline
        MLS      & 0x15 & Store Register \\
        \hline
\end{tabular}

\subsection{Stack}

        \textbf{Brief}

        Stack operations are used to implement call conventions.

        \textbf{0x01 - many-bit}

        \begin{tabular}{ | l | l | l | }
        Mnemonic & Opcode & Brief \\
        \hline
        PSH      & 0x16 & Push Register \\
        \hline
        PSM      & 0x17 & Push Many Registers \\
        \hline
        POP      & 0x18 & Pop Register \\
        \hline
        POM      & 0x19 & Pop Many Registers \\
        \hline
\end{tabular}

\section{Control Flow}

\subsubsection{Flow Unit}

        \textbf{Brief}

        The Flow Unit controls program control flow by the means of branches.

 \begin{tabular}{ | l | l | l | }
        Mnemonic & Opcode & Brief \\
        \hline
        JMP      & 0x20 & Branch Unconditionally; Absolute \\
        \hline
        JMP      & 0x21 & Branch Unconditionally; Relative \\
        \hline
        BZ       & 0x22 & Branch If Zero \\
        \hline
        BNZ      & 0x23 & Branch if Non-Zero \\
        \hline
        BEQ      & 0x22 & Synonymous with Branch if Zero (Equal) \\
        \hline
        BNE      & 0x23 & Synonymous with Branch if Non-Zero (Not Equal) \\
        \hline
        BLT      & 0x24 & Branch if Less Than \\
        \hline
        BLE      & 0x25 & Branch if Less Than or Equal \\
        \hline
        BGT      & 0x26 & Branch if Greater Than \\
        \hline
        BLE      & 0x27 & Branch if Greater Than or Equal \\
        \hline
        BO       & 0x28 & Branch if Overflow \\
        \hline
        BNO      & 0x29 & Branch if No Overflow \\
        \hline
        BC       & 0x2a & Branch if Carry Set \\
        \hline
        BNC      & 0x2b & Branch if Carry Not Set \\
        \hline
        CSR      & 0x2c & Call Sub-Routine (narg) \\
        \hline
        BEG      & 0x2d & Begin Sub-Routine (nvar) \\
        \hline
        FIN      & 0x2e & Finish Sub-Routine (nvar) \\
        \hline
        RET      & 0x2f & Return From Sub-Routine (val) \\
        \hline
\end{tabular}

\section{Input-Output}

        \textbf{Brief}

        Input-Output operations are used to configure and communicate with
        auxiliary devices.

        \textbf{low 3 bits - size shift count}

\begin{tabular}{ | l | l | l | }
        Mnemonic & Opcode & Brief \\
        \hline
        RDB      & 0x30 & Read 8-Bit Byte \\
        \hline
        RDH      & 0x31 & Read 16-Bit Half-Word \\
        \hline
        RDW      & 0x32 & Read 32-Bit Half-Word \\
        \hline
        RDL      & 0x33 & Read 64-Bit Long-Word \\
        \hline
        WRB      & 0x34 & Read 8-Bit Byte \\
        \hline
        WRH      & 0x35 & Read 16-Bit Half-Word \\
        \hline
        WRW      & 0x36 & Read 32-Bit Half-Word \\
        \hline
        WRL      & 0x37 & Read 64-Bit Long-Word \\
        \hline
        IOR      & 0x39 & Set or Query I/O Read Permission \\
        \hline
        IOW      & 0x3a & Set or Query I/O Write Permission \\
        \hline
\end{tabular}

	\subsubsection{System Unit}

\newpage

\section{Memory Organization}

	\textbf{Notes}

	System page size is 4096 bytes.

\begin{tabular}{ | l | l | l | }
	\hline
	Address                     & Purpose           & Brief \\
	\hline
	0                           & interrupt vector  & interrupt handler descriptors \\
	\hline
	4096                        & keyboard buffer   & keyboard input queue \\
	\hline
	8192                        & text segment      & application program code (read-execute) \\
	\hline
	8192 + TEXTSIZE             & data segment      & program data (read-write) \\
	\hline
	DATA + DATASIZE             & BSS segment       & uninitialised data (runtime-allocated and zeroed) \\
        \hline
        3G                          & system space      & operating system \\
	\hline
	MEMSIZE to TLS              & dynamic segment   & free space for slab a
locator \\
	\hline
	3.5G - NTHR * THRSTKSIZE    & thread-local storage (TLS) & allocated on-demand \\
\hline
        3.5 gigabytes               & graphics          & draw buffer \\
                                    & memory mapped devices & \\
	\hline
\end{tabular}

\chapter{Instruction Set}

	The VPU instruction set was designed to resemble the C language closely,
	as well as to support a RISC-oriented set of typical machine operations.

\section{Instruction Reference}

\subsection{Instruction Set}

	\textbf{Operands}

	The table below lists operand types.

\begin{itemize}
	\item{\textbf{i} stands for immediate operand}
	\item{\textbf{r} stands for register operand}
	\item{\textbf{m} stands for memory operand}
\end{itemize}

	\textbf{Flags}

	Certain instructions set bits in the machine status word register (MSW).
	This is	documented here on per-instruction basis.

\begin{itemize}
	\item{\textbf{z} stands for zero flag (ZF)}
	\item{\textbf{c} stands for carry flag (CF)}
	\item{\textbf{o} stands for overflow flag (OF)}
	\item{\textbf{s} stands for sign flag (SF)}
\end{itemize}

	\textbf{TODO}: stack/call conventions for certain instructions such as THR

\subsection{Instruction Table}

        \textbf{TOREDO}

\subsection{I/O Port Map}

	\textbf{I/O Address Space}

	The I/O address space maps 65,536 I/O ports to unsigned 16-bit address
	space.

\begin{tabular}{| l | l | l | l | l |}
	\hline
	Port \# & Name & Default \\
	\hline
	\textbf{0x0000} & STDIN & keyboard input \\
	\hline
	\textbf{0x0001} & STDOUT & console output \\
	\hline
	\textbf{0x0002} & STDERR & error output \\
	\hline
\end{tabular}

\chapter{Assembly}

\section{Syntax}

	\textbf{AT\&T Syntax}

	We use so-called AT\&T-syntax assembly. Perhaps the most notorious
	difference from Intel-syntax is the operand order; AT\&T lists the
	source operand first, destination second, whereas Intel syntax does it
	vice versa.

	\textbf{Symbol Names}

	Label names must start with an underscore or a letter; after that, the
	name may contain underscores, letters, and digits. Label names end with
	a ':', so like

\begin{minted}{gas}
	val:	.long 0xb4b5b6b7
\end{minted}

	would declare a longword value at the address of \textbf{value}.

	\textbf{Instructions}

	The instruction operand order is source first, then destination. For
	example,

\begin{minted}{gas}
	lda	8(%r0), %r1
\end{minted}

	would load the value from address \textbf{r0 + 8} to the register
	\textbf{r1}.

	\textbf{Operands}

	Register operand names are prefixed with a '\textbf{\%}. Immediate
	constants and direct addresses are prefixed with a \'textbf{\$}'. Label
	addresses are refered to as their names without prefixes.

	The assembler supports simple preprocessing (of constant-value
	expressions), so it is possible to do things such as

\begin{minted}{gas}
	.define	FLAG1	0x01
	.define	FLAG2	0x02

	lda	$(FLAG1| FLAG2), %r1
\end{minted}

	\textbf{Registers}

	Register names are prefixed with '\%'; there are 16 registers r0..r15.
	For example,

\begin{minted}{gas}
	add	%r0, %r1
\end{minted}

	would add the longword in r0 to r1.

	\textbf{Direct Addressing}

	Direct addressing takes the syntax

\begin{minted}{gas}
	lda	val, %r0
\end{minted}

	which moves the longword at \textbf{address val} into r0.

	\textbf{Indexed Addressing}

	Indexed	addressing takes the syntax

\begin{minted}{gas}
	lda	4(%r0), %r1
\end{minted}

	where 4 is an integral constant offset and r0 is a register name. In
	short, this would store the value at the address \textbf{r0 + 4} into
	r1.

	\textbf{Indirect Addressing}

	Indirect addresses are indicated with a \textbf{'*'}, so

\begin{minted}{gas}
	lda	*%r0, %r1
\end{minted}

	would store the value from the \textbf{address in the register r0}
	into register r1, whereas

\begin{minted}{gas}
	lda	*val, %r0
\end{minted}

	would move the value \textbf{pointed to by val} into r0.

	Note that the first example above was functionally equivalent with

\begin{minted}{gas}
	lda	(%r0), %r1
\end{minted}

	\textbf{Immediate Addressing}

	Immediate addressing takes the syntax

\begin{minted}{gas}
	lda	$str, %r0
\end{minted}

	which would store the \textbf{address of str} into r0.

\section{Assembler Directives}

\section{Input Directives}

\subsection{.include}

	The \textbf{.include} directive takes the syntax

\begin{minted}{gas}
	.include <stdio.inc>
\end{minted}

	to insert \textbf{<stdio.inc>} into the translation stream verbatim.

\subsection{.import}

	The \textbf{.import} directive takes the syntax

\begin{minted}{gas}
	.import <file.asm>
\end{minted}

	or

\begin{minted}{gas}
	.import <file.obj>
\end{minted}

	to import foreign assembly or object files into the stream.
	\textbf{Note} that only symbols declared with \textbf{.globl} will be
	made globally visible to avoid namespace pollution.

\section{Link Directives}

\subsection{.org}

	The \textbf{.org} directive takes a single argument and sets the linker
	location address to the given value.

\subsection{.space}

	The \textbf{.space} directive takes a single argument and advances the
	link location address by the given value.

\subsection{.align}

	The \textbf{.align} directive takes a single argument and aligns the
	next label, data, or instruction to a boundary of the given size.

\subsection{.globl}

	The \textbf{.globl} directive takes one or several symbol names
	arguments and declares the symbols to have global visibility (linkage).

\section{Data Directives}

\subsection{.long}

	\textbf{.long} takes any number of arguments and declares in-memory
	32-bit entities.

\subsection{.byte}

	\textbf{.byte} takes any number of arguments and declares in-memory
	8-bit entities.

\subsection{.short}

	\textbf{.short} takes any number of arguments and declares in-memory
	16-bit entities.

\subsection{.asciz}

	\textbf{.asciz} takes a C-style string argument of characters enclosed
	within double quotes ('"'). Escape sequences '$\backslash$n' (newline),
	'$\backslash$t' (tabulator), and '$\backslash$r' (carriage return) are supported.

\subsection{Preprocessor Directives}

\section{.define}

	\textbf{.define} lets one declare symbolic names for constant (numeric)
	values. For example, if you have

	\textbf{<hook.def>}

\begin{minted}{gas}
        .define STDIN  0
        .define STDOUT 1
        .define STDERR 2
\end{minted}

\section{Input and Output}

	The pseudo machine uses some predefined ports for keyboard and console
	I/O. The currently predefined ports are

\begin{tabular}{ | l | l | l | }
	\hline
	Port & Use            & Notes \\
	\hline
	0x00 & keyboard input & interrupt-driven \\
	0x01 & console output & byte stream \\
	0x02 & error output   & directed to console by default \\
	\hline
\end{tabular}

\section{Simple Program}

	The following code snippet prints the string \"hello\" + a newline to
	the console. Note that the string is saved using the standard C
	convention of NUL-character termination.

\begin{minted}{gas}
        msg:        .asciz	"hello\n"

        .align      4

        _start:
                sta        $msg, %r0
                ldb        *%r0, %r1
                ldb        $0x01, %r2
                cmp        $0x00, %r1
                bz         done
        loop:
                inc        %r0
                outb       %r1, %r2
                ldb       *%r0, %r1
                cmp        $0x00, %r1
                bnz        loop
        done:
                hlt
\end{minted}

\section{Threads}

	The pseudo machine supports hardware threads with the \textbf{thr}
	instruction. It takes a single argument, which specifies the new
	execution start address; function arguments should be passed in
	registers.

\section{Example Program}

	The following piece of code shows simple utilisation of threads.

\begin{minted}{gas}
        .import <bzero.asm>

        memzero:
                lda        $65536, %r0       // address
                lda        $4096, %r1        // length
                call       bzero
                hlt

        _start:
                thr        $memzero
                hlt
\end{minted}

\section{Interrupts}
	Software- and CPU-generated interrupts are often refered to as
	\textbf{traps}. I call those and hardware-generated
	\textbf{interrupt requests} interrupts, collectively.

\subsection{Interrupt Interface}

	The lowest page (4096 bytes) in virtual machine address space contains
	the \textbf{interrupt vector}, i.e. a table of interrupt handler
	addresses to trigger them.

	Interrupt handler invokations only push the \textbf{program counter}
	and \textbf{old frame pointer}, so you need to reserve the registers
	you use manually. This is so interrupts could be as little overhead as
	possible to handle.

\subsection{Keyboard Input}

	In order to read keyboard input without polling, we need to hook the
	\textbf{interrupt 0}. This is done in two code modules; an interrup
	handler as well as other support code.

	I will illustrate the interrupt handler first.

\subsection{Keyboard Interrupt Handler}

	\textbf{TODO: example interrupt handler}

\subsubsection{Keyboard Support Code}

	\textbf{TODO: queue keypresses in 16-bit values; 32-bit if full Unicode requested}.

\end{document}

