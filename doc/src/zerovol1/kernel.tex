\documentclass[twoside, a4paper]{book}
\usepackage[T1]{fontenc}
\normalsize
\usepackage{listings}
\usepackage{parskip}
\usepackage{verbatim}
\usepackage{fancyvrb}
\usepackage{hyperref}
\lstset{language=C, showspaces=false, breaklines=false}
\usepackage[table, gray]{xcolor}
\setlength{\arrayrulewidth}{1pt}
\rowcolors{0}{white}{lightgray}
\hypersetup{colorlinks=true, linkcolor=blue}

\begin{document}

\title{\LARGE{Zero Volume 0 - The Kernel} \\
       \large{Design and Implementation} \\
       \large{DRAFT 1, Revision 13}}
\author{Tuomo Petteri Venäläinen}
\date{\today}
\maketitle

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{4}
\setlength{\parindent}{0cm}

\tableofcontents

\part{Overview}

	Zero is an operating system project; at the time of this writing, the
	project has several pieces under construction, some of them rather good
	already.

	Zero is open source. The choice of license is the so-called New BSD
	License; I chose it over the GPL in the hopes of possibly making it easy
	to adopt this software for business projects - after all, we all have to
	make a living. I do, however, plan to keep the base system (the kernel
	and support software) open source and free of charge; I have the feeling
	tailoring Zero for needs of clients might be fruitful for business.

	At the moment, I have implemented the so-far-relevant parts of the C
	standard library implementation for 3 platforms: 32-bit X86 (IA-32),
	64-bit X86 (AMD64), and some versions of the ARM microprocessor family.
	I would love to port the kernel to all of these as well as other
	platforms such as some 64-bit architectures common in UNIX workstations
	during the old times. Alpha, MIPS, Sparc, PowerPC etc. With such
	interests, donations of old server and workstation hardware would be
	very welcome, provided I have the room to set them up. :)

\chapter{Preface}

	\textbf{Goal}

	The goal of the Zero project is a new, portable, high performance,
	UNIX-inspired operating	system. Such systems typically consist of a
	[relatively] small kernel and supporting user software such as editors,
	compilers, linkers and loaders, and other software development tools.

	\textbf{Rationale}

	Whereas different UNIX-like operating systems are doing strong for many
	users, the world is a different place from when UNIX and some of the
	related operating systems had their initial designs laid out. We have
	outstanding graphics (and physics) processors, high quality audio
	interfaces, lots of memory, plenty of disk space, and so forth. Also,
	the trend is leaning towards multiprocessor systems with new
	requirements and possibilities. I think and feel it's worth designing a
	new operating system for modern computers.

	\textbf{Design}

	Zero is a multithreaded multiprocessor-enabled kernel. Design goals
	include fast response to user interaction as well as high multimedia
	performance.

\section{Acknowledgements}

\subsection{Contributors}

	At the moment, I have kept Zero mostly a one-man project on purpose. I
	feel it's too much of a moving target to spend other people's time
	working on things that may change any moment. I will do my best to bring
	Zero ready for others to work on - I have been offered help, and I want
	to thank you guys (who know yourself) here. :)

	At the time being, I want to thank \textbf{Craig Robbins} for some
	graphical effects, \textbf{Leonardo Taglialegne} for some audio hacks,
	and \textbf{Ivan Rubinson} for some graphics. :)

\subsection{Open Source Community}

	First and foremost, I want to thank \textbf{the developers} of open and
	free software for their work and courage to release their work for
	others to use and modify. Keep strong in spirit!

	As their work has been used for the purpose of inspiration, thanks go to
	\textbf{Carsten 'raster' Haitzler} and his team for their work on
	\textbf{Enlightenment} and their mission to reinvent graphical user
	interfaces. Keep up the good work, guys! :)

\section{Background}

	Zero has its roots in early, simple and elegant versions of the UNIX
	operating system. I still see many good, timeless things about UNIX
	design worth reusing in a new operating system. One thing of particular
	attraction is the "everything is a file" philosophy; I plan to use and
	possibly extend that idea in Zero.

\chapter{System Concepts}

	This chapter is a glossary of some terminology used throughout the book.

\section{General Terminology}

	\textbf{Buffer}

	Buffers are used to avoid excess I/O system calls when reading and
	writing to and from I/O devices. Buffer memory is allocated from a
	separate buffer cache, which may be either static or dynamic size.
	On Zero, buffer pages are 'wired' to memory; they will never get paged
	out to disk or other external devices, but instead buffer eviction leads
	to writing the buffer to a location on some device; typically a disk.

	\textbf{Event}

	Events are a means for the kernel and user processes to communicate with
	each other. As an example, user keyboard input needs to be encoded to
	a well known format (Unicode or in the case of a terminal, ISO 8859-1
	or UTF-8 characters) and then dispatched to the event queues of the
	listening processes. Other system events include creation and destroyal
	of files and directories.

	Zero schedules certain events on timers separate from the timer
	interrupt used for scheduling threads. At the time of such an event, it
	is dispatched to the event queues of [registered] listening processes;
	if an event handler thread has been set, it will be given a short time
	slice of the event timer. Event time slices should be shorter than
	scheduler time slices to not interfere with the rest of the system too
	much.

	\textbf{Event Task}

	Certain events trigger threads or processes listening to them to run for
	a short period of time immediately. The timer used may be the same as
	for interval tasks (see \textbf{Fast Timer}). The idea is to let
	user interaction events 'steal' a bit of time from the rest of the
	system.

	\textbf{Fast Timer}

	A timer separate from the standard thread scheduling timer. In default
	configuration, the fast timer fires an interrupt 1,000 times a second,
	whereas normal threads are scheduled slices of 4 millisecond at the
	frequency of 250 Hz. On X86 platforms, HPET event timers are utilised.

	\textbf{Interval Task}

	Short-lived, frequent tasks such as audio and video buffer
	synchronisation are scheduled with priority higher than normal tasks.
	It is likely such tasks should be given a slice of time shorter than
	other threads.

	\textbf{Hybrid Scheduler}

	See \textbf{Event Task}, \textbf{Fast Timer}, and \textbf{Interval Task}
	for more information.

	\textbf{Page}

	A page is the base unit of memory management. Hardware protection works
	on per-page basis. Page attributes include read-, write-, and
	execute-permissions. For typical programs, the text (code) pages would
	have read- and execute-permissions, wherease the program [initialised]
	data pages as well as [unitialised] BSS-segment pages would have read-
	and write- but not execute-permissions. This approach facilitates
	protection against overwriting code and against trying to execute code
	from the data and BSS-segments.

	\textbf{Process}

	A process is a running instance of a program. A process may consist of
	several threads. Threads of a process share the same address space, but
	have individual execution stacks.

	\textbf{Segment}

	Processes typically consist of several segments. These include a text
	segment for [read-only] code, a data segment for initialised global
	data, a BSS-segment for uninitialised global data, and different
	debugging-related segments. Note that the BSS-segment is runtime-
	allocated, whereas the data segment is read from the binary image. Also
	Note that in a different context, segments are used to refer to hardware
	memory management.

	\textbf{Signal}

	Signals are asynchronous events. Signals may be delivered by the kernel,
	by other processes, or by a process itself. Typical uses include
	notifying processes of things such as division by zero (SIGFPE),
	undefined memory access (SIGSEGV and SIGBUS) or illegal machine
	instructions (SIGILL).

	Two predefined signals exists for application use; SIGUSR1 and SIGUSR2.

	\textbf{Task}

	In the context of Zero, the term task is usually used to refer to either
	\textbf{a process or a thread}.

	\textbf{Thread}

	Threads are the basic execution unit of programs. To utilise
	multiprocessor-parallelism, a program may consist of several threads
	of execution, effectively letting it do several computation and	I/O
	operations at the same time.

	\textbf{Trap}

	A trap is a hardware- or software generated event. Other names for traps
	include \textbf{interrupts}, \textbf{exceptions}, \textbf{faults}, and
	\textbf{aborts}. As an example, keyboard and mouse input may generate
	interrupts to be handled by interrupt service routines (\textbf{ISR}s).

	\textbf{Virtual Memory}

	Virtual memory is a technique to map physical memory to per-process
	address space. The processes see their address spaces as if they were in
	total control of the machine. These per-process address spaces are
	protected from being tampered by other processes. Address translations
	are hardware-level (the kernel mimics them, though), so virtual memory
	is transparent to application, and most of the time, even kernel
	programmers.

\section{X86 Terminology}

	\textbf{APIC}

	APIC stands for [CPU-local] 'advanced programmable interrupt
	controller.'

	\textbf{GDT}

	A GDT is 'global descriptor table', a set of memory segments with
	different permissions.

	\textbf{HPET}

	HPET is short for high precision event timer (aka multimedia timer).

	\textbf{IDT}

	IDT means interrupt descriptor table (aka interrupt vector).

	\textbf{ISR}

	ISR stands for interrupt service routine, i.e. interrupt handler.

	\textbf{LDT}

	An LDT is local descriptor table', a set of memory segments with
	different permissions.

	\textbf{PIT}

	PIT stands for programmable interrupt timer. This timer may be used to
	schedule threads on uniprocessor systems; for modern PCs, look into
	\textbf{APIC}.

\chapter{System Features}

\section{UNIX Features}

	\textbf{Concepts}

	Zero is influenced and inspired by AT\&T and BSD UNIX systems. As I
	think many of the ideas in these operating systems have stood the test
	of time	nicely, it feels natural to base Zero on some well-known and
	thoroughly-tested concepts.

	\textbf{Nodes}

	Nodes are similar with UNIX 'file' descriptors. All I/O objects,
	lock structures needed for IPC and multithreading, as well as other
	types of data structures are called nodes, collectively. Their [64-bit]
	IDs are typically per-host kernel \textbf{memory addresses} (pointer
	values) for kernel \textbf{descriptor data structures}.

\section{POSIX Features}

	\textbf{Threads}

	Perhaps the most notable POSIX-influenced feature in Zero kernel is
	threads. POSIX- and C11-threads can be thought of as light-weight
	'processes' sharing the parent process address space but having unique
	execution stacks. Threads facilitate doing several operations at the
	same time, which makes into better utilisation of today's multicore-
	and multiprocessor-systems.

\section{Zero Features}

	\textbf{Events}

	Possibly the most notable extension to traditional UNIX-like designs in
	Zero is the event interface. Events are interprocess communication
	messages between kernel and user processes. Events are used to notify
	of user device (keyboard, mouse/pointer) input, filesystem actions such
	as removal and destroyal of files or directories, as well as to
	communicate remote procedure calls and data between two processes
	(possibly on different hosts).

	Events are communicated using message passing; the fastest transport
	available is chosen to deliver messages from a process to another one;
	in a scenario like a local display connection, messages can be passed
	by using a shared memory segment mapped to the address spaces of both
	the kernel and the desktop server.

\section{Compile-Time Configuration}

	The table below lists some features of the Zero kernel that you can
	configure at compile-time. The list is not complete; for more settings,
	consult \textbf{<kern/conf.h>}.

\begin{tabular}{ | l | l | l | }
	\hline
	Macro        & Brief & Notes \\
	\hline
	\textbf{SMP} & multiprocessor support & Not functional yet \\
	\hline
	\textbf{HZ}  & timer frequency        & default value is 250 \\
	\hline
	\textbf{ZEROSCHED} & default scheduler & do not change yet \\
	\hline
	\textbf{NPROC}     & maximum simultaneous processes & default is 256 \\
	\hline
	\textbf{NTHR}      & maximum simultaneous threads   & default is 4096 \\
	\hline
	\textbf{NCPU}      & number of CPU units supported  & default is 8 if \textbf{SMP} is non-zero \\
	\hline
\end{tabular}

\part{Basic Kernel}

\chapter{Kernel Layout}

	\textbf{Monolithic Kernel}

	Zero is a traditional, monolithic kernel. It consists of several code
	modules, some notable ones of which are listed below.

\begin{tabular}{ | l | l | }
	\hline
	Module        & Desription \\
	\hline
	\textbf{tmr}  & hardware timer interface \\
	\hline
	\textbf{proc} & process interface \\
	\hline
	\textbf{thr}  & thread scheduler \\
	\hline
	\textbf{vm}   & virtual memory manager \\
	\hline
	\textbf{page} & page daemon \\
	\hline
	\textbf{mem}  & kernel memory allocator \\
	\hline
	\textbf{io}   & I/O primitives \\
	\hline
	\textbf{buf}  & block/buffer cache management \\
	\hline
\end{tabular}

	The code modules above will be discussed in-depth in the later parts of
	this book.

\chapter{Processor Support}

	Initially, Zero shall support 32-bit and 64-bit X86 architectures. The
	plan is to port Zero at least to ARM in addition.

\section{Thread Scheduler}

\subsection{Thread Classes}

	The following code snippet lists thread classes in decreasing order of
	priority.

	\textbf{TODO: add thread classes when final}

\subsection{Priorities}

	\textbf{Priority Queue}

	Zero scheduler uses a queue with $THRNCLASS * THRNPRIO$ priorities.

	\textbf{Priority Adjustment}

	Every time a thread stops running, its priority is adjusted with the
	function below.

	\textbf{TODO: implement a simple hybrid priority adjustment algorithm}

\subsection{Data Structures}

	The structures \textbf{struct proc} and \textbf{struct thr} are declared
	in \textbf{<kern/obj.h>}. The example implementations below are for the
	\textbf{IA-32} architecture.

\newpage

	\textbf{struct proc}

	The process data structure, of the type \textbf{struct proc}
	consists of per-process book-keeping data shared between all threads of
	the process.

	\textbf{IA-32 Implementation}

	\textbf{TODO: add final proc structure}

	\textbf{struct thr}

	The thread data structure, of the type \textbf{struct thr}, consists of
	machine-specific and portable members.

	\textbf{IA-32 Implementation}

	\textbf{TODO: add final thr structure}

\section{Interrupt Vector}

	The interrupt vector is an array of interrupt descriptors. The
	descriptors contain interrupt service routine base address for the
	function to be called to handle the interrupt.

	The symbolic [macro] names for interrupts and IRQs (interrupt requests)
	are declared in \textbf{<kern/unix/x86/trap.h}.

\newpage

\subsection{X86 Interrupts}

	The following table lists X86 interrupts along with their associated
	signals.

\begin{tabular}{ | l | l | l | l | }
	\hline
	Macro    & Number & Description                        & Signal \\
	\hline
	TRAPDE   & 0x00	  & divide error; fault                & SIGFPE \\
	\hline
	TRAPDB   & 0x01	  & reserved; fault/trap               & N/A \\
	\hline
	TRAPNMI  & 0x02	  & non-maskable interrupt; interrupt  & N/A \\
	\hline
	TRAPBP   & 0x03	  & breakpoint; trap                   & SIGTRAP \\
	\hline
	TRAPOF   & 0x04	  & overflow; trap                     & N/A \\
	\hline
	TRAPBR   & 0x05	  & bound range exceeded; fault        & SIGBUS \\
	\hline
	TRAPUD   & 0x06	  & invalid opcode; fault              & SIGILL \\
	\hline
	TRAPNM   & 0x07	  & no FPU; fault                      & SIGILL \\
	\hline
	TRAPDF   & 0x08	  & double-fault; fault, error == 0    & N/A \\
	\hline
	TRAPRES1 & 0x09	  & reserved                           & N/A \\
	\hline
	TRAPTS   & 0x0a	  & invalid tss; fault + error         & N/A \\
	\hline
	TRAPNP   & 0x0b	  & segment not present; fault + error & SIGSEGV \\
	\hline
	TRAPSS   & 0x0c	  & stack-segment fault; fault + error & SIGSTKFLT \\
	\hline
	TRAPGP   & 0x0d	  & general protection; fault + error  & SIGSEGV \\
	\hline
	TRAPPF   & 0x0e	  & page-fault; fault + error          & N/A \\
	\hline
	TRAPRES2 & 0x0f	  & reserved                           & N/A \\
	\hline
	TRAPMF   & 0x10	  & FPU error; fault + number          & SIGFPE \\
	\hline
	TRAPAC   & 0x11	  & alignment check; fault, error == 0 & SIGBUS \\
	\hline
	TRAPMC   & 0x12	  & machine check; abort               & SIGABRT \\
	\hline
	TRAPXF   & 0x13	  & SIMD exception; fault              & SIGFPE \\
	\hline
\end{tabular}

\subsection{IRQs}

	The following table lists default use of IRQs 0 through 0x0f (15). Zero
	redirects these to interrupts 0x20 through 0x2f (32 to 47).

\begin{tabular}{ | l | l | l | }
	\hline
	Macro       & Number & Description \\
	\hline
	IRQTIMER    & 0      & timer interrupt \\
	\hline
	IRQKBD      & 1      & keyboard interrupt \\
	\hline
	IRQCOM2AND4 & 3      & serial ports 2 and 4 \\
	\hline
	IRQCOM1AND3 & 4      & serial ports 1 and 3 \\
	\hline
	IRQLPT      & 5      & parallel port \\
	\hline
	IRQFD       & 6      & floppy disk drive \\
	\hline
	IRQRTC      & 8      & real-time clock \\
	\hline
	IRQMOUSE    & 12     & mouse \\
	\hline
	IRQFPU      & 13     & floating point unit \\
	\hline
	IRQIDE0     & 14     & IDE controller 1 \\
	\hline
	IRQIDE1     & 15     & IDE controller 2 \\
	\hline
\end{tabular}

\subsection{Interrupt Descriptors}

	Entries in the interrupt vector, i.e. interrupt descriptor table
	(\textbf{IDT}), are called interrupt descriptors. These descriptors,
	whereas a bit hairy format-wise, consist of interrupt handler address,
	protection ring (system or user), and certain other attribute flags.

\chapter{Memory}

\section{Segmentation}

	Zero uses what is traditionally called a flat memory model; the use of
	segmentation is kept to the bare minimum required for successful code
	execution. Protection is done at page level.

	A process may use either a global descriptor table with its physical
	address in the GDT-register or a local one with the address in the
	LDT-register. Processes are required to declare a handful of entries
	into their descriptor tables.

	A segment descriptor is a CPU-specific data structure. On \textbf{IA-32}
	and \textbf{X86-64} architectures, the descriptors have base address and
	limit fields, permission bits, and other such values.

\section{Paging Data Structures}

	Protection and other control of memory appears on per-page basis.

\subsection{Page Directory}

	The page directory points to page tables; page tables, in turn, point to
	pages that may or may not be present in physical memory. This provides
	a hierarchical view of memory; by providing a virtual address, it is
	possible to obtain a physical one for memory access.

\subsection{Page Tables}

\section{Page Daemon}

\subsection{Zone Allocator}

	The Zero memory manager was crafted to use aggressive buffering of
	allocations. The higher buffer level is a \textbf{Bonwick}-style
	\textbf{magazine} layer consisting of allocation stacks for sub-slab
	blocks.	The lower level is a typical \textbf{slab allocator} dealing
	with slabs of power of two sizes to make book-keeping easier.

\subsection{Page Replacement Algorithm}

\chapter{I/O}

\section{Hardware I/O}

\subsection{Character I/O Transfers}

	Some devices operate in character based (raw) mode. This is typically
	feasible for so-called slow devices such as terminals. It is noteworthy
	that a system call needs to be triggered for every character.

\subsection{Block I/O Transfers}

	Block I/O works using a buffer cache mechanism. Instead of doing
	single-character operations, I/O is buffered using bigger blocks
	(typically 4 to 64 kilobytes) to dramatically reduce the number of
	system calls involved in I/O operations.

	Block based devices include hard drives, optical drives, and network
	interfaces. In case of network packets, the system caches checksums for
	static data to avoid redoing it on retransmittal.

\chapter{Inter-Process Communications (IPC)}

	Zero provides typical IPC primitives such as mutexes and generic
	semaphores, shared memory, and message queues.

	Mutexes (binary semaphores) and other semaphores are used to restrict
	access to critical regions; e.g., linked lists need to be locked to
	avoid simultaneous access by multiple threads to ensure consistency of
	list data.

	Shared memory is a fast form of IPC; shared memory is physical memory
	mapped to virtual address spaces of the kernel and user processes. It's
	recommended to use shared memory where possible to obtain zero-copy (or
	close) message passing.

\chapter{System Call Interface}

	\textbf{TODO}

	Keep in mind, that the interface described here is currently
	\textbf{incomplete}; therefore, please consult the final interface
	later.

	The most notable missing things at the moment are support for sockets
	as well as semaphores.

\section{Conventions}

	By convention, system calls return -1 on failure.

\subsection{System Call Mechanism}

\subsubsection{Interrupt 0x80}

	On \textbf{IA-32} architectures, all of up to 3 system call parameters
	are passed in registers; the system call number is in \textbf{EAX}. On
	\textbf{X86-64}	all system call arguments are passed in registers. On
	both architectures, system calls return a value for \textbf{errno}; the
	value is returned in \textbf{EAX} on IA-32, and in \textbf{RAX} on
	X86-64. \textbf{Failures} are indicated by setting the \textbf{CF-bit}
	(carry)	in the \textbf{EFLAGS}-register. System calls are, in the first
	implementation, triggered by \textbf{interrupt 0x80}.

\subsubsection{SYSENTER and SYSEXIT}

	\textbf{TODO: sysenter + sysexit}

\section{Process Control}

\subsection{sysctl}

	\textbf{long sys\_sysctl(long cmd, long parm, void *arg);}

	The sysctl system call is used to trigger certain system control
	operations. The commands, their arguments, and the return values are
	listed in the next table.

\begin{tabular}{ | l | l | l | l | }
	\hline
	\textbf{cmd} & \textbf{parm} & \textbf{arg} & Returns \\
	\hline
	\textbf{SYS\_INIT} & runlevel & N/A & new runlevel \\
	\hline
\end{tabular}

	\textbf{TODO: SYS\_INIT (SYS\_HALT, SYS\_REBOOT), ...}

\subsection{exit}

	\textbf{long sys\_exit(long val, long flg);}

	The exit system call terminates the calling process. The process returns
	\textbf{val} as its exit status. If \textbf{flg} has the
	\textbf{EXIT\_DUMPACCT} bit set, process accounting information is
	dumped into the \textbf{/var/log/acct.log} system log file.

\subsection{abort}

	\textbf{void sys\_abort(void);}

	The abort system call terminates the calling process in an abnormal way.
	If the limit for core dump size is set to be big enough, a memory image
	of the process is dumped into a \textbf{core} file. The location of this
	file may be either the local directory or one configured in
	\textbf{/etc/proc/core.cfg}.

\subsection{fork}

	\textbf{long sys\_fork(long flg);}

	The fork system call creates a new child process. The return value is
	the process ID of the new child process in the parent, and 0 (zero) in
	the child process. If \textbf{flg} has the \textbf{FORK\_VFORK} bit set,
	the new process shall share the	parent's address space; otherwise, the
	child's address space will be a	clone of the parent's address space. If
	\textbf{flg} has the \textbf{FORK\_COW} (copy on write) bit set, the new
	process will only clone pages as they are written on.

\subsection{exec}

	\textbf{long sys\_exec(char *path, char *argv[], ...);}

	The exec system call replaces the calling process by an instance of
	the program \textbf{path}. The argument vector \textbf{argv} holds
	argument strings for the program to be executed; the table must be
	terminated by a final \textbf{NULL} pointer.

	If a third argument is given, it shall be \textbf{char **} used as
	\textbf{environment} strings for the program; the table must be
	terminated by a final \textbf{NULL} pointer.

\newpage

\subsection{throp}

	\textbf{long sys\_throp(long cmd, long parm, void *arg);}

	The throp system call provides thread control. The \textbf{cmd} argument
	is one of the values in the following table.

\begin{tabular}{ | l | l | l | l | }
	\hline
	\textbf{cmd} & \textbf{parm} & \textbf{arg} & Notes \\
	\hline
	\textbf{THR\_NEW}     & class & struct thrarg *  & pthread\_create() \\
	\hline
	\textbf{THR\_JOIN}    & thrid & struct thrjoin * & pthread\_join() \\
	\hline
	\textbf{THR\_DETACH}  & N/A   & N/A              & pthread\_detach() \\
	\hline
	\textbf{THR\_EXIT}    & N/A   & N/A              & pthread\_exit() \\
	\hline
	\textbf{THR\_CLEANUP} & N/A   & N/A              & cleanup; pop and execute handlers etc. \\
	\hline
	\textbf{THR\_KEYOP}   & cmd   & struct thrkeyop * & create, delete \\
	\hline
	\textbf{THR\_SYSOP}   & cmd   & struct thrsys *  & atfork, sigmask, sched, scope \\
	\hline
	\textbf{THR\_STKOP}   & thrid & struct thrstk *  & stack; addr, size, guardsize \\
	\hline
	\textbf{THR\_RTOP}    & thrid & struct thrrtop * & realtime thread settings \\
	\hline
	\textbf{THR\_SETATR}  & thrid & struc thratr *  & set other attributes \\
	\hline
\end{tabular}

\subsection{pctl}

	\textbf{long sys\_pctl(long cmd, long parm, void *arg);}

	\textbf{TODO: pid as parm, special values for the choices}

	The pctl system call provides process operations. The following tables
	list provided functionality.

\begin{tabular}{ | l | l | l | l | }
	\hline
	\textbf{cmd}             & \textbf{parm} & Notes \\
	\hline
	\textbf{PROC\_GETPID}    & N/A           & getpid() \\
	\hline
	\textbf{PROC\_GETPGRP}   & N/A           & getpgrp() \\
	\hline
	\textbf{PROC\_WAIT}      & -1            & wait for any child \\
	                         & pid > 0       & wait for pid \\
	                         & pid == 0      & wait for children in the group of caller \\
                                 & pid < -1 & wait for children in the group abs(pid) \\
	\hline
	\textbf{PROC\_USLEEP}    & milliseconds  & usleep() \\
	\hline
	\textbf{PROC\_NANOSLEEP} & nanoseconds   & nanosleep() \\
	\hline
\end{tabular}

	\textbf{Notes}

	For \textbf{PROC\_WAIT}, if \textbf{arg} is NULL or
	\textbf{struct rusage *} for collecting resource usage statistics.

\begin{tabular}{ | l | l | l | l | }
	\hline
	\textbf{cmd} & \textbf{parm} & \textbf{arg} & Notes \\
	\hline
	\textbf{PROC\_SETSCHED}      & attribute bits & struct syssched * & set scheduling parameters \\
	\hline
	\textbf{PROC\_STAT}          & pid or RUSAGE\_SELF & struct rusage * & get resource usage statistics \\
	\hline
	\textbf{PROC\_GETLIM}        & limit bits & struct rlimit * & read process limits \\
	\hline
	\textbf{PROC\_SETLIM}        & limit bits & struct rlimit * & set process limits \\
	\hline
\end{tabular}

\subsection{sigop}

	\textbf{long sys\_sigop(long cmd, long parm, void *arg);}

	The sigop system call provides control over signals and related program
	behavior. The diffent values for \textbf{cmd} as well as related values
	for \textbf{parm} are shown in the following table.

\begin{tabular}{ | l | l | l | l | }
	\hline
	\textbf{cmd}          & \textbf{parm}    & \textbf{arg} & \textbf{Notes} \\
	\hline
	\textbf{SIG\_WAIT}    & N/A     & N/A             & pause() \\
	\hline
	\textbf{SIG\_SETFUNC} & sig     & struct sigarg * & signal()/sigaction() \\
	\hline
	\textbf{SIG\_SETMASK} & N/A     & sigset\_t *     & sigsetmask() \\
	\hline
	\textbf{SIG\_SEND}    & N/A     & sigset\_t *     & raise() etc. \\
	\hline
	\textbf{SIG\_SETSTK}  & N/A     & struct sigstk * & sigaltstack() \\
	\hline
	\textbf{SIG\_SUSPEND} & N/A     & sigset\_t *     & sigsuspend(), sigpause() \\
	\hline
\end{tabular}

	\textbf{Structure Declarations}

\begin{verbatim}
/* flg bits */
#define SIG_NOCLDSTOP 0x01	// no SIGCHLD on stop or cont
#define SIG_ONSTACK   0x02	// use sigaltstk() stack
#define SIG_RESETHAND 0x04	// reset handler to SIG_DFL
#define SIG_RESTART   0x08	// no EINTR behavior
#define SIG_SIGINFO   0x10	// func(int, siginfo_t, void *)
struct sigarg {
    long  sig;	// signal ID
    long  flg;	// see SIG_-macros above
    void *func;	// signal disposition
};
\end{verbatim}

\section{Memory Interface}

\subsection{brk}

	\textbf{long sys\_brk(void *adr);}

	The brk system call sets the current break, i.e. top of heap, of the
	calling process to \textbf{adr}. The return value is 0 on success, -1 on
	failure.

\subsection{map}
	\textbf{void *sys\_map(long desc, long flg, struct sysmem *arg);}

	The map system call is used to map [zeroed] anonymous memory or files
	to the calling process's virtual address space. For compatibility with
	existing systems, mapping the device special file \textbf{/dev/zero} is
	similar to using the \textbf{flg} value of \textbf{MAP\_ANON}.

	The return value is user virtual memory address of the mapped region or
	((void *)-1) on failure.

\begin{tabular}{ | l | l | }
	\hline
	flg             & Notes \\
	\hline
	\textbf{MAP\_FILE}       & object is a file (may be /dev/zero) \\
	\hline
	\textbf{MAP\_ANON}       & map anonymous memory set to zero \\
	\hline
	\textbf{MAP\_SHARED}     & changes are shared \\
	\hline
	\textbf{MAP\_PRIVATE}    & changes are private \\
	\hline
	\textbf{MAP\_FIXED}      & map to provided address \\
	\hline
	\textbf{MAP\_SINGLE}     & map buffer to single user process and kernel \\
	\hline
	\textbf{MEM\_NORMAL}     & normal behavior \\
	\hline
	\textbf{MEM\_SEQUENTIAL} & sequential I/O buffer \\
	\hline
	\textbf{MEM\_RANDOM}     & random-access buffer \\
	\hline
	\textbf{MEM\_WILLNEED}   & don't unmap after use; keep in buffer cache \\
	\hline
	\textbf{MEM\_DONTNEED}   & unmap after use \\
	\hline
	\textbf{MEM\_DONTFORK}   & do not share with child processes \\
	\hline
\end{tabular}

	\textbf{Structure Declarations}

\begin{verbatim}
struct sysmem {
    void *base;	// base address
    long  ofs;	// offset in bytes
    long  len;	// length in bytes
    long  perm;	// permission bits
};
\end{verbatim}

\subsection{umap}

	\textbf{long sys\_umap(void *adr, size\_t size);}

	The umap system call unmaps memory regions mapped with sys\_map().

\subsection{mhint}

	\textbf{long sys\_mhint(void *adr, long flg, struct sysmem *arg);}

	The mhint system call is used to hint the kernel of a memory region
	use patterns. The possible bits for \textbf{flg} are shown in the table
	below; for \textbf{struct sysmem} declaration, see \textbf{map}.

\begin{tabular}{ | l | l | }
	\hline
	\textbf{MEM\_NORMAL}     & default behavior \\
	\hline
	\textbf{MEM\_SEQUENTIAL} & sequential I/O buffer \\
	\hline
	\textbf{MEM\_RANDOM}     & random-access buffer \\
	\hline
	\textbf{MEM\_WILLNEED}   & don't unmap after use; keep in buffer cache \\
	\hline
	\textbf{MEM\_DONTNEED}   & unmap after use \\
	\hline
	\textbf{MEM\_DONTFORK}   & do not share with forked child processes \\
	\hline
\end{tabular}

\section{Shared Memory}

	The shared memory interface of Zero is modeled after the POSIX
	interface.

\subsection{shmget}

	\textbf{long sys\_shmget(long key, size\_t size, long flg);}

	The shmget system call maps a shared memory segment; it returns a shared
	memory identifier (usually a long-cast of a kernel virtual memory
	address). If \textbf{key} is \textbf{IPC\_PRIVATE}, a new segment and
	its associated book-keeping data are created. If \textbf{flg} has the
	\textbf{IPC\_CREAT} bit set and there's no segment associated with
	\textbf{key}, a new segment is created in concert with the relevant
	data.

\subsection{shmat}

	\textbf{void *sys\_shmat(long id, void *adr, long flg);}

	The shmat system call atteaches the shared memory segment identified by
	\textbf{id} to the address space of the calling process. If \textbf{adr}
	is NULL, the segment is attached to the first address selected by the
	system. If \textbf{adr} is not NULL and \textbf{flg} has the
	\textbf{SHM\_RND} bit set, the segment is mapped to \textbf{adr} rounded
	down to the previous multiple of \textbf{SHMLBA}. If \textbf{adr} is not
	NULL and \textbf{flg} does \textbf{not} have the \textbf{SHM\_RND} bit
	set, the segment is mapped to \textbf{adr}. If \textbf{flg} has the
	\textbf{SHM\_RDONLY} bit set, the segment is attached
	\textbf{read-only}; otherwise, provided the user process has read and
	write permissions, the segment is attached \textbf{read-write}.

\subsection{shmdt}

	\textbf{long sys\_shmdt(void *adr);}

	The shmdt system call detaches the shared memory segment at
	\textbf{adr} from the address space of the calling process.

\subsection{shmctl}

	\textbf{void sys\_shmctl(long id, long cmd, void *arg);}

	The shmctl system call provides control operations for shared memory
	segments. The possible values for \textbf{cmd} are listed in the
	following table.

\begin{tabular}{ | l | l | l | }
	\hline
	\textbf{cmd}       & \textbf{arg}       & brief \\
	\hline
	\textbf{IPC\_STAT} & struct shmid\_ds * & read segment attributes \\
	\hline
	\textbf{IPC\_SET}  & struct shmid\_ds * & set segment permissions (uid, gid, mode) \\
	\hline
	\textbf{IPC\_RMID} & N/A                & destroy shared memory segment \\
	\hline
\end{tabular}

\section{Semaphores}

	\textbf{long sys\_seminit(void);}

	The seminit system call initialises a semaphore at the given virtual
	user address to unlocked state. The kernel maps the semaphore to its own
	virtual address space and returns the \textbf{ID of the new semaphore}.

	The return value is the ID of the new semaphore on success, -1 on
	failure.

\subsection{semup}

	\textbf{long sys\_semup(long id);}

	The semup system call atomically increases the value of a semaphore. The
	return value is the new semaphore value or -1 on failure:

\subsection{semdown}

	\textbf{long sys\_semdown(long id);}

	The semup system call atomically decreases the value of a semaphore. The
	return value is the new semaphore value or -1 on failure.

\subsection{semop}

	\textbf{long sys\_semop(long id, long cmd, long flg);}

	The semop system call performs a semaphore operation. See the table
	below for defined values.

\begin{tabular}{ | l | l | l | }
	\textbf{cmd} & \textbf{flg} & brief \\
	\hline
	IPC\_STAT    & N/A          & obtain semaphore value \\
	\hline
	IPC\_SET     & permissions  & set semaphore permissions \\
	\hline
	IPC\_RMID    & N/A          & remove semaphore \\
	\hline
\end{tabular}

\section{Message Queues}

	\textbf{TODO}: MQSYNC-priority (0)

\subsection{mqinit}

	\textbf{long sys\_mqinit(long perm, long prio, long nbyte);}

	The mqinit system call initialises a message queue with permissions and
	priority as supplied. The nbyte parameter determines the size of the
	region allocated for queue messages in octets.

	mqinit returns the ID of the new message queue or -1 on failure

\subsection{mqsend}

	\textbf{long sys\_mqsend(long qid, void *buf, long nbyte);}

	The mqsend system call sends nbyte bytes of message data from buffer to
	the specified queue. If the queue is too full for the message to fit,
	the system call will block until the transmittal can be processed; if,
	however, the queue was initialised with MQASYNC, the system call will
	return and the data shall be transmitted asynchronously.

	The return value is the number of bytes sent or -1 on failure.

\subsection{mqrecv}

	\textbf{long sys\_mqrecv(long qid, void *buf, long nbyte);}

	The return value is the number of bytes received, 0 if the message
	queue is empty, and -1 on failure.

\subsection{mqop}

	\textbf{long sys\_mqop(long qid, long cmd, long parm);}

\section{Events}

	/* TODO: EVSHM, EVMQ */

\subsection{evreg}

	\textbf{long evreg(long ev, long flg, void (*func)(void *buf));}

	The evreg system call registers a handler function for the supplied
	event type.

\subsection{evsend}

	\textbf{long evsend(void *buf, long flg, long dest);}

	The evsend system call sends an event stored in a buffer to a receiver
	such as a desktop window (shared memory queue) or message queue
	(local or remote over a network)

\subsection{evrecv}

	\textbf{long evrecv(void *buf, long flg, long src);}

	The evrecv system call reads an event from a source such as shared
	memory (local) or a message queue (local or remote).

\subsection{evop}

	\textbf{long sys\_evop(long cmd, long flg, void *atr);}

\section{I/O}

\part{User Environment}

\section{Process Environment}

\section{Memory Map}

\begin{tabular}{ | l | l | l | }
	\hline
	Segment          & Brief                 & Parameters \\
	\hline
	\textbf{stack}   & process stack         & read, write, grow-down \\
	\hline
	\textbf{map}     & memory-mapped regions & read, write \\
	\hline
	\textbf{heap}    & process heap (sbrk()) & read, write \\
	\hline
	\textbf{bss}     & uninitialised data    & read, write, allocate \\
	\hline
	\textbf{data}    & initialised data      & read, write \\
	\hline
	\textbf{text}    & process code          & read, execute \\
	\hline
\end{tabular}

	\textbf{Notes}

\begin{itemize}
	\item{memory regions are shown from highest to lowest address, i.e. the
	addresses grow upwards}
	\item{the stack segment grows downwards in memory}
	\item{the BSS segment is allocated at run-time}
\end{itemize}

\end{document}

\appendix

\chapter{Notes on Tuning Code}

\section{Preface}

	This document demonstrates low-level code optimization techniques as
	well as simple data structures useful for high-performance data
	processing. The goal is to introduce the reader to some aspects of the
	magic of tuning code.

	Compilers massage code, people tune code. There is a difference.
	The best compiler cannot undo a bad design. Tuning code may not be
	rocket science, but it's definitely art and lots of fun.

\section{KISS Principle}

	Keep it simple, stupid/silly. The philosophy behind tuning code. CPUs
	are reasonably simple and good at doing simple things. The less you make
	them do, the faster the code will run.

	The fact that algorithmic optimizations, i.e. picking efficient
	algorithms as the first part of optimization, won't be given much
	attention in this document. Instead, I will concentrate on lower-level
	optimizations such as data organization.

	I'm of the belief that tuning code is mostly about knowing the machine.
	Therefore, I will discuss CPU internals on a generic level in ways that
	should be widely applicable. You will see that there's more to efficient
	code than first meets the eye.

\section{C Language}

	The C language is one of the biggest contributions to software
	technology. C is basically as low-level as you can get without resorting
	to assembly. C has been given the nickname of "pseudo-assembly". The
	basic CPU environment of registers, memory, and I/O has been abstracted,
	but thinly. If this abstraction gets too much on your way, you can
	usually use inline assembly, i.e. mix assembly code with C.

	You can, most of the time, think of variables as registers. Most C
	programs use pointers quite a bit; they can be considered memory
	addresses. In short, C programmers are dealing with what the CPU is;
	operations on and between registers and memory.

\subsection{C Integer Operations}

	The following tables contain relative speeds of some C operations; note
	that the actual timings vary from platform to platform, so perhaps the
	most important thing concerning integral arithmetics is the slow
	execution of division and modulus operations.

	\textbf{Arithmetic Operations}

	\textbf{TODO: replace with new data, include shift operations}

\begin{verbatim}
	op	  ticks/op   microseconds    iterations
	--	  --------   ------------    ----------
	++        6          17              1024
	--        6          18              1024
	+         6          17              1024
	-         6          18              1024
	*         8          21              1024
	/         12         32              1024
	\%        36         86              1024

	logical ops
	op      tick/op usecs   count
	--      ------- -----   -----
	&       2       8       1024
	|       2       8       1024
	^       2       9       1024
	~       2       8       1024
	!       4       12      1024
\end{verbatim}

	\textbf{Notes}

	The speed measurements above were run on a single P3-450 CPU. Note that
	whereas most arithmetic operations are about equal in speed, integer
	division is a bit slower and modulus is very slow. Therefore,
	it's worth knowing that for integral x and power-of-two value p2,

\begin{verbatim}
	y= x % p2;

        is equivalent with

        y = x & (p2 - 1);
\end{verbatim}

	To find out if x is a power of two, you can use

\begin{verbatim}
	#define powerof2(x) (!((x) & ((x) - 1)))
\end{verbatim}

	In other words, you can replace the very slow modulus with very fast
	logical operations. Note how logical operations run quite a bit faster
	than arithmetic. ;)

\section{C Floating Point Operations}


\begin{verbatim}
	float
	-----
	op      tick/op usecs   count
	--      ------- -----   -----
	+       9       23      1024
	-       9       24      1024
	*       109     250     1024
	/       124     284     1024

	double
	------
	op      tick/op usecs   count
	--      ------- -----   -----
	+       9       25      1024
	-       9       25      1024
	*       51      118     1024
	/       125     286     1024

	long double
	-----------
	op      tick/op usecs   count
	--      ------- -----   -----
	+       11      29      1024
	-       12      30      1024
	*       14      35      1024
	/       40      95      1024
\end{verbatim}

	\textbf{Notes}

	As is the case with integer math, addition and subtraction are
	reasonably fast. However, division is very slow.

	An interesting thing to notice is that added precision may even speed
	things up. :)

\section{Computer Architecture}

\subsection{Von Neumann Machine}

	A Von Neumann machine consists of three parts - CPU, memory, and I/O
	facilities.

	\textbf{Dies and Cores}

	A core is a CPU execution unit, basically a set of hardware registers
	and mathematical units that operate on them.

	Multicore systems have several cores on the same die, i.e. the same
	package. So called SMP (symmetric multiprocessor) systems are more
	traditional. They consist of several dies with one core on each.

	\textbf{Conclusions}

	Most of the time, the programmer need not be concerned about the
	hardware details. It may, however, pay back to implement CPU-intensive
	applications using multiple threads in the hopes the system might be
	capable of executing several of the threads simultaneously.

\subsection{ALU}

	ALU, arithmetic-logical unit, is a central part of a CPU. Implementation
	is, naturally, architecture-dependent, but the unit is used for
	reasonably simple arithmetic and logical operations.

\subsection{FPU}

	FPU, floating point unit, is used for floating-point calculations.
	There may, for example, be machine instructions for operations such as
	sine and cosine.

	Even though the days of slow floating-point operations may be history,
	there's still a point in not using floating-point to minimize the number	of registers that need to be saved on task switches.

	As a special case, I'm trying to keep my kernel all-integer in order to
	speed up in-kernel context switches.

\subsection{MMU}

	MMU, memory management unit, is a part of a CPU that handles [kernel-
	level] virtual memory. Virtual addresses can be mapped to arbitrary
	physical addresses to facilitate paging data in and out transparently
	to the programmer. MMUs implement schemes to protect memory from
	unwanted access.

	As a fast form of IPC (interprocess communications), shared memory
	deserves to be mentioned. Shared memory can be implemented by mapping
	pieces of physical memory (RAM) to address spaces of several processes.

\subsection{Prefetch Queue}

	Prefetch queues are used to read chunks of instruction data at a time.
	It's a good idea not to use many branching constructs, i.e. jump around 
	in code, to keep the CPU from not having to flush its prefetch queue
	often.

\subsection{Branch Prediction}

	CPUs may implement branch prediction logic to try to prefetch code to
	be executed into CPU instruction cache. Branches should be avoided where
	possible to avoid pipeline stalls (slows execution speed down) and when
	they are necessary, it's good form to put the most likely branches to be
	taken first. In some cases, excess branches can be avoided either with
	switch/case, or with function pointer tables.

\subsection{Pipeline}

	CPU pipelines are used to split instruction execution into several
	phases and try to execute different phases of adjacent instructions in
	parallel.

	A common technique to schedule instructions is to avoid data
	dependencies in adjacent operations; targets of an operation shouldn't
	be sources for the next one. This will reduce pipeline stalls and keep
	the CPU running code faster.

\section{Basic Techniques}

\subsection{Inlining}

	Inlining is a technique to duplicate pieces of code in order to avoid
	function calls. Function calls cause overhead because register state
	needs to be saved and restored; As this overhead shouldn't be long on
	current computers, inlining should probably only be used for small
	operations and/or left to the compiler to do.

	To reduce instruction cache misses, it's probably better to avoid code-
	duplication from excess inlining.

	If you can deal with the so-called debugging possibilities, macros are
	perhaps the best and definitely the most portable way to inline code.

\subsection{Loop Unrolling}

	Unrolling a loop means executing several loop iterations in one actual
	loop iteration. This is done to avoid looping overhead, e.g. updating
	index variables and pipeline stalls.

\subsection{Constants}

	If you see a constant used repetitively in code, it may be a good idea
	to assign it to a variable to hint the compiler to store it into a
	register. This way, instructions may become shorter as there is no need
	to encode [big] constant values into instruction.

	It may be fruitful to make constants as small as possible; the compiler
	should realize to know this, but I find code more appealing to read when
	hex constants of 2, 4, 8, or 16 digits are used to represent 8-bit,
	16-bit, 32-bit, and 64-bit values respectively.

\subsection{Memory Access}

	In short, memory access should be avoided. When you need to do it, try		to avoid cache misses and keep your data aligned.

\subsection{Alignment}

	As a rule of thumb, align words to the boundaries of their size, i.e.
	where the address is an exact multiple of the size.

	CPUs read memory a fixed number of bytes at a time. This means memory
	operands are fetched a given number of bytes at a time; you should
	minimize this number.

\subsection{Cache}

	A bit higher, CPUs read a cacheline's worth of data at a time. To avoid
	cache misses and so slow access to main physical memory, you should
	keep your data on as few cachelines as possible; in structures, try to
	keep related values close to each other.

\section{Simple Data Structures}

\subsection{Bitmaps}

	Bitmaps are useful for storing simple state information. For example,
	if you really only have to differentiate two states from each other,
	say free and busy, it would be a big overhead to store boolean values
	into words.

\subsection{Lookup Tables}

	If, for example, property determination gets complex, especially if it
	leads to lots of branching, it may be feasible to use lookup tables to
	store operation values that can be accessed in constant time; note,
	however, that there's a memory access which may be a slow task.

	As a useful trick, long switch statements can often be replaced byy a
	short piece of code to index a function pointer tables with the 'case'
	values. This way, the execution time will be constant.

\subsection{Hash Tables}

	The idea of hash tables is to map given keys to indices into a [fixed-
	size] table. Key collisions can be dealt with simple linked lists.
	Picking a proper hash function for calculating keys, e.g. from character
	strings, should ensure that the lists (chains) don't get long so lookups
	will run fast. Note, though, that hash tables are practically impossible
	to sort without using other data structures to help. Hash tables may use
	lots of memory; pay attention to the table size.

\subsection{Stacks}

	Stacks are a very simple data structure, in some ways limited, but also
	very fast for some of simple operations.

	A basic stack provides push and pop operations to store and receive the
	topmost item, respectively. This is easy to implement as a
	(possibly single-direction) linked list.

	\textbf{Example}

\begin{verbatim}
	#include <stdio.h>;

	struct page *pagestk;

	struct page {
	    void        *addr;
	    struct page *next;
	};

	#define pushpage(page) ((page)->next = pagestk,
	                        pagestk = (page))
	#define poppage(tmp)   ((tmp) = pagestk, \
	                        pagestk
			            = ((tmp)
				       ? (tmp)->next
				       : NULL),
			        (tmp))

	int
	main(int argc,
	     char *argv)
	{
	    struct page *tmp;
	    struct page  pg1 = { &pg1, NULL };
	    struct page  pg2 = { &pg2, NULL };

	    fprintf(stderr, "push\t%p\n", &pg1);
	    pushpage(&pg1);
    	    fprintf(stderr, "push\t%p\n", &pg2);
    	    pushpage(&pg2);
    	    fprintf(stderr, "pop\t%p\n", poppage(tmp));
    	    fprintf(stderr, "pop\t%p\n", poppage(tmp));
    	    fprintf(stderr, "pop\t%p\n", poppage(tmp));

    	    exit(0);
	}
\end{verbatim}

\section{Tricks}

\begin{verbatim}
	/* zero page, 32-bit version. */

	void
	pzero(void *ptr)
	{
	    unsigned long  zero = 0;        /* do not embed big constant into loop. */
    	    unsigned long  cnt = PGSZ >> 4; /* loop count. */
    	    unsigned long *ulptr = ptr;     /* unsigned long at a time. */

    	    /*
     	     * - using small constants as pointer offsets is faster than variables
     	     *   for me.
     	     *   -vendu
     	     */
	    while (cnt--) {
                ulptr[0] = ulptr[1] = ulptr[2] = ulptr[3] = zero;
        	 ulptr += 4;
	    }

	    return;
	}
\end{verbatim}

\chapter{Tools of the Trade}

\section{Software}

	\textbf{http://www.valgrind.org/}

	great memory debugger (and cache simulator)

	\textbf{http://icl.cs.utk.edu/papi/software/}

	PAPI performance monitor

\section{Suggested Reading}

	\textbf{http://www.plantation-productions.com/Webster/www.writegreatcode.com/index.html}

	Hyde, Randall; Write Great Code book series

	\textbf{http://www.hackersdelight.org/}

	Warren, Henry S Jr.; Hacker's Delight

	\textbf{http://www.amazon.com/Code-Optimization-Effective-Memory-Usage/dp/1931769249}

	Kaspersky, Kris; Code Optimization: Effective Memory Usage

	\textbf{http://ourworld.compuserve.com/homepages/rbooth/}

	Booth, Rick; Inner Loops

\section{Links}

	\textbf{http://aggregate.org/MAGIC/}

	Aggregate Magic Algorithms

	\textbf{http://graphics.stanford.edu/~seander/bithacks.html}

	Stanford Bit Twiddling Hacks

	\textbf{http://www.inwap.com/pdp10/hbaker/hakmem/hakmem.html}

	MIT HAKMEM

\chapter{System Calls}

\chapter{IA-32 and X86-64 Implementations}

\section{Calling Conventions}

\subsection{Stack Frames}

\section{Hardware Interface}

\subsection{Memory Segments}

\subsection{Traps}

\subsection{Trap Frames}


